\documentclass[a4paper, 11pt]{report}
\usepackage{graphicx} % Required for inserting images
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{tikz,lipsum,lmodern}
\usepackage[most]{tcolorbox}
\usepackage{pgfplots}
\usepackage{tabularx}
\usepackage{stmaryrd}
\usepackage{tikz} 
\usetikzlibrary{shapes.geometric}
\usepackage{imakeidx}
\usepackage{hyperref}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{cleveref}
\usepackage{listings}
\usepackage{algorithm}
\usepackage{algpseudocode}

\usetikzlibrary{calc}
\makeindex[columns=3, title=Alphabetical Index, intoc]
\hypersetup{
    colorlinks=true,
    linkcolor=blue!50!green!70!black,
    filecolor=magenta,      
    urlcolor=blue,
    pdftitle={Max flows in O(nm) time, or better},
    pdfpagemode=FullScreen,
    }

\newcommand*{\QED}{\null\nobreak\hfill\ensuremath{\square}}%
\newcommand*{\proof}{\textit{proof}:\\}
\newcommand*{\mb}[1]{\mathbb{#1}}
\newcommand*{\mc}[1]{\mathcal{#1}}
\newcommand{\dlt}{$\Delta$}
\newcommand{\gmm}{$\Gamma$}

\definecolor{bananamania}{rgb}{0.98, 0.91, 0.71}
\definecolor{amaranth}{rgb}{0.9, 0.17, 0.31}
\definecolor{amethyst}{rgb}{0.6, 0.4, 0.8}
\definecolor{darktangerine}{rgb}{1.0, 0.66, 0.07}
\definecolor{cerise}{rgb}{0.87, 0.19, 0.39}
\definecolor{babyblue}{rgb}{0.54, 0.81, 0.94}
\definecolor{brightgreen}{rgb}{0.4, 1.0, 0.0}

\definecolor{comment}{rgb}{0.5, 0.5, 0.5}
\definecolor{string}{rgb}{0.3, 0.6, 0.3}
\definecolor{keyword}{rgb}{0.7, 0, 0.4}
\definecolor{identifier}{rgb}{0.2, 0.2, 1}
\definecolor{background}{rgb}{0.99, 0.99, 0.99}


\lstdefinestyle{customcpp}{
    language=C++,
    basicstyle=\ttfamily\footnotesize,
    backgroundcolor=\color{background},
    keywordstyle=\color{keyword},
    identifierstyle=\color{identifier},
    commentstyle=\color{comment}\itshape,
    stringstyle=\color{string},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=10pt,
    tabsize=4,
    showspaces=false,
    showstringspaces=false,
    breaklines=true,
    breakatwhitespace=true,
    escapeinside={\%*}{*)},
    frame=single,
    rulecolor=\color{black},
    captionpos=b,
    morekeywords={override, nullptr},
}

\newtcbtheorem[auto counter]{theo}%
  {Theorem}{fonttitle=\bfseries,
    colback=white!5!white,colframe=amaranth}{theo}

\newtcbtheorem[auto counter,number within=section]{corollary}%
    {Corollary}{fonttitle=\bfseries,
      colback=white,colframe=cerise}{corollary}

\newtcbtheorem[auto counter]{definition}%
    {Definition}{fonttitle=\bfseries,
    colback=white!5!white,colframe=teal!60!green}{definition}

\newtcbtheorem[auto counter]{lemma}%
    {Lemma}{fonttitle=\bfseries,
    colback=white!5!white,colframe=amethyst}{lemma}

\newtcbtheorem[auto counter]{obs}%
    {Observation}{fonttitle=\bfseries,
    colback=white!5!white,colframe=darktangerine}{obs}

\newtcbtheorem[auto counter]{proposition}%
    {Proposition}{fonttitle=\bfseries,
    colback=white!5!white,colframe=magenta}{proposition}

\newtcbtheorem[auto counter]{algo}%
    {Algorithm}{fonttitle=\bfseries,
    colback=white,colframe=green!50!black!60!blue}{algo}

\newtcbtheorem[auto counter]{remark}%
    {Remark}{fonttitle=\bfseries,
    colback=white,colframe=bananamania,coltitle = brown!45!black}{remark}

\newtcbtheorem[auto counter]{example}%
    {Example}{fonttitle=\bfseries,
    colback=white,colframe=babyblue!70!white,coltitle = blue!45!black}{example}

\titlespacing*{\chapter}{0pt}{-20pt}{20pt} % Riduce lo spazio prima del titolo del capitolo
\titleformat{\chapter}[display]
  {\normalfont\Large\bfseries} % Stile del titolo
  {\chaptername\ \thechapter}{10pt}{\huge}

\title{Max flows in O(nm) time, or better\\
\large Appunti per la tesi}

\author{Armando Coppola}
\date{\today}



\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage
\section*{Introduzione}
Ciò che segue è una relazione che ha lo scopo di analizzare la soluzione proposta nell'algoritmo di Orlin per il calcolo del \textbf{max flow in un Network}.
Dato che per comprendere a pieno il suo funzionamento è necessario conoscere anche alcuni algoritmi precedenti, anche questi vengono spiegati nella relazione. 
Gli algoritmi sono presentati in ordine cronologico a partire dall'algoritmo di Dinics, continuando con Goldberg-Rao e giungendo alla soluzione più recente e efficace di Orlin.
Prima di iniziare con le soluzioni però, è presente un capitolo che spiega alcune nozioni preliminari sulla teoria dei grafi necessarie per comprendere il funzionamento delle soluzioni.

\chapter{Preliminary notions}
\section{Network e flow}
\begin{definition}{Network}{}
    Definiamo un Network come una struttura composta da un grafo $G = (N,E)$ tale che:\begin{itemize}
        \item N = insieme dei nodi 
        \item E = $\{(i,g)\land i,g \in N \}$ insieme degli archi 
        \item $n$ = $|N|$
        \item $m$ = $|E|$
    \end{itemize}
    e composta da una funzione $u: E \rightarrow \mathbb{N}^+\cup \{+\infty\}$ che denota la capacità di ogni arco.
    \[u(i,j) = \text{capacità dell'arco } (i,j)\]
    \begin{center}
        \textit{indicheremo di seguito la capacità $u(i,j)$ con l'abbreviazione $u_{ij}$}
    \end{center}
\end{definition}
In ogni Network esistono due nodi speciali, s \textit{source} e t \textit{sink}. lo scopo di un Network è inviare flusso dal nodo s al nodo t.
\begin{figure}
    \centering
    \begin{tikzpicture}[node distance={18mm}, thick, main/.style = {draw, circle}] 
        \node[main] (0) {$s$}; 
        \node[main] (1) [above right of=0] {$1$};
        \node[main] (2) [below right of= 0] {$2$};
        \node[main] (3) [above right of = 2] {$3$};
        \node[main] (4) [above right of=3] {$4$};
        \node[main] (5) [below right of=3] {$5$};
        \node[main] (6) [below right of=4] {$t$};
        
    
    
        \draw[->] (0) to [bend left = 20] (1);

    
        \draw[->] (0) to [bend right = 20] (2);

    
        \draw[->] (2) to [bend left= 20] (3);
        \draw[->] (3) to [bend left= 20] (2);
    
        \draw[->] (1) to [bend left= 20] (3);
        \draw[->] (3) to [bend left= 20] (1);

        \draw[->] (4) to [bend left= 20] (3);
        \draw[->] (3) to [bend left= 20] (4);

        \draw[->] (5) to [bend left= 20] (3);
        \draw[->] (3) to [bend left= 20] (5);

        \draw[->] (1) to [bend left= 20] (4);
        \draw[->] (4) to [bend left= 20] (1);


        \draw[->] (4) to [bend left= 20] (6);

        \draw[->] (5) to [bend left= 20] (2);
        \draw[->] (2) to [bend left= 20] (5);

        \draw[->] (5) to [bend right= 20] (6);

    
    \end{tikzpicture} 
    \caption{Esempio classico di un Network}
\end{figure}



\begin{definition}{$U_{min},\ U_{max}$}{}
    In ogni nodo definiamo come:
    \begin{itemize}
        \item $U_{min}$: la più piccola capacità non zero associata ad un arco:
        \[U_{min} = u_{ij} | (i,j) \in E\ \land\ u_{ij} > 0\ \land\ \nexists (k,l) \in E : 0<u_{kl}<u_{ij}\]
        \item $U_{max}$: la più grande capacità finita 
        \[U_{max} = u_{ij}| (i,j) \in E\land u_{ij} \not = + \infty\ \land \]
        \[\nexists (k,l) \in E : u_{ij}< u_{jl} < +\infty \]
    \end{itemize}
\end{definition}
distingiuiamo gli archi del Network in:\\
\textbf{External Arcs} := $\{(x,y) | (x,y)\in E \land (x = s \lor y = t)\}$\\
\textbf{Internal Arcs} := $\{(x,y) | (x,y)\in E \land x \not = s \land y \not = t\}$ ovvero $E \setminus External\ Arcs$\\
\\
Assumeremo che per ogni $(i,j)$ internal arc allora esiste $(j,i) \in E$.\\ In oltre per ogni internal node $i$ esiste $(s,i) \in E \land (i,t) \in E$ eventualmente con capacità 0
\begin{obs}{}{}
    Il nodo $s$ non ha archi entranti come il nodo $t$ non ha archi uscenti
\end{obs}

\begin{definition}{Flow}{}
    Definiamo come con la funzione $f: E \rightarrow\mathbb{R}_+ \cup \{0\}$ che soddisfa la $flow\ conservation$
    \[\sum_{j:(i,j) \in E} f_{ij} - \sum_{j:(j,i) \in E}f_{ji} = 0 \quad \forall i \in N\setminus\{s,t\}\]
\end{definition}

Un \textit{flow} si dice \textit{feasible} se $\forall (i,j) \in E,\ f_{ij} \le u_{ij}$(\textit{capacity constraints}).\\
Il valore del flow è dato dalla somma del flow degli archi uscenti da s o entranti in t.  
\begin{definition}{residual capacity}{}
    La capacità residua da $i \rightarrow j$ indica la quantita di flusso che si può ancora immettere dal nodo i al nodo j
    \[r_{ij} = u_{ij} + f_{ji} - f_{ij}\]    
    quando parleremo di capacità residue secondo diversi flow potremmo usare anche la notazione:
    \[u_f(i,j)\]
    che indica proprio la capacità residuo di un arco attraversato dal flow $f$
\end{definition}

\begin{definition}{Residual Graph}{}
    Dato un Network $\mc{N}$ e un un flusso $f$ definito sul grafo possiamo definire il grafo residuo come 
    \[G_f := (N(\mc{N}), \{(i,j) | (i,j)\in E(\mc{N}) \land r_{ij} > 0\})\]
    
\end{definition}

\begin{definition}{s-t Cut}{}
    Definiamo come $s-t\ Cut$ la partizione di G in due sottoinsiemi (S,T) tali che:
    \begin{enumerate}
        \item $s \in S$
        \item $t \in T$
        \item $S \cap T = \varnothing$
        \item $S \cup T = N$
    \end{enumerate}
    
    La \textit{capacità} del Cut è definita come:
    \[u(S,T) = \sum_{i\in S\land j\in T} u_{ij}\]
    Il \textit{residuo} del taglio: è definito come:
    \[r(S,T) = \sum_{i\in S\land j\in T} r_{ij}\]
\end{definition}

\begin{lemma}{Max residual flow min residual cut}{}
    Dato un grafo residuo $G_f$ e un cut (S,T) allora $r(S,T)$ rappresenta l'upper bound dell flusso da $s \rightarrow t$.
    In particolare, il massimo incremento di flow rispetto ad $r$ è la capacita residua minore di un s-t cut.  
\end{lemma}
\textit{dimostrazione omessa}\\
Il lemma riporta che il problema di trovare il flusso massimo su un Network è \textbf{duale} a quello di trovare un taglio di capacità minima sullo stesso network in quanto questo rappresenterà il collo di bottiglia che fa da upper bound all'aumento di flusso.

\begin{definition}{Anti-symetric subset}{}
    Dato $E(j)$ l'insieme degli archi adiacenti con j definiamo come \textit{Anti-symetric} subset 
    \[E'(j) :=\{(x,y)|(x,y)\in E(j) \land (x,y) \in E'(j) \iff (y,x) \not\in E'(j)\}\] 
\end{definition}
\textbf{Esempio:}\\
\begin{center}
    
\begin{tabular}{cc|cc}
    $E(j)  $&\qquad &\qquad& $E'(j)  $\\
\begin{tikzpicture}[node distance={15mm}, thick, main/.style = {draw, circle}] 
    \node[main] (1) {$j$}; 
    \node[main] (2) [above right of=1] {$b$};
    \node[main] (3) [below right of=1] {$c$};
    \node[main] (4) [above left of=1] {$a$};
    \node[main] (5) [below left of=1] {$d$};


    \draw[->] (2) to [bend left] (1);
    \draw[->] (1) to [bend left] (2);

    \draw[->] (3) to [bend left] (1);
    \draw[->] (1) to [bend left] (3);

    \draw[->] (4) to [bend left] (1);
    \draw[->] (1) to [bend left] (4);

    \draw[->] (5) to [bend left] (1);
    \draw[->] (1) to [bend left] (5);

\end{tikzpicture} 
&&
&
\begin{tikzpicture}[node distance={15mm}, thick, main/.style = {draw, circle}] 
    \node[main] (1) {$j$}; 
    \node[main] (2) [above right of=1] {$b$};
    \node[main] (3) [below right of=1] {$c$};
    \node[main] (4) [above left of=1] {$a$};
    \node[main] (5) [below left of=1] {$d$};



    \draw[->] (1) to [bend right] (2);


    \draw[->] (1) to [bend left] (3);

    \draw[->] (4) to [bend right] (1);


    \draw[->] (5) to [bend left] (1);


\end{tikzpicture} 
\end{tabular}
\end{center}
\begin{lemma}{Anti-symmetriy lemma}{}
    Dato $E'(j)$ un anti-symmetric subset di $E(j)$ e un flusso $f$ su $G$ con $r = r[f]$ allora:
    \[\sum_{(i,j)\in E'(j)}r_{ij} - \sum_{(j,i)\in E'(j)}r_{ji} = \sum_{(i,j)\in E'(j)}u_{ij} - \sum_{(j,i)\in E'(j)}u_{ji} \]
\end{lemma}
\begin{proof}
    \[\sum_{(i,j)\in E'(j)}r_{ij} - \sum_{(j,i)\in E'(j)}r_{ji} -\sum_{(i,j)\in E'(j)}u_{ij} + \sum_{(j,i)\in E'(j)}u_{ji}= 0 \implies\]
    \[\sum_{(i,j)\in E'(j)}(u_{ij}-r_{ij}) + \sum_{(j,i)\in E'(j)}(u_{ji}-r_{ji}) = 0 \]
    dato che $r_{ij} = u_{ij} - f_{ji} + f_{ij} \implies u_{ij} -r_{ij} = f_{ji}- f_{ij}$ 
    \[\sum_{(i,j)\in E'(j)}(f_{ji}-f_{ij}) + \sum_{(j,i)\in E'(j)}(f_{ij}-f_{ji}) = \sum_{(i,j)\in E(j)}(f_{ji}-f_{ij}) = 0\]
    ovvero il vincolo di \textit{conservazione del flow}
    \QED
\end{proof}
\section{Decomposition e transfering del flow}

\begin{definition}{Flow decomposiiton}{}
    Dato $f$ un $s-t$ flow su $N$, definiamo  \textit{flow-decomposition}, una collezione di $s-t$ path diretti
    \[P_1, ..., P_s\quad \phi_1,..., \phi_s\]
    tale che: \begin{enumerate}
        \item $\forall (u,v) \in P_i, f(u,v)> 0$
        \item $f(P_i) = \phi_i\ \forall i, \in [1,s]$
        \item $ val(f) = \sum_{i = 1}^s \phi_i$
    \end{enumerate}


\end{definition}
Un \textbf{osservazione} intuitiva è che il massimo numero di decomposizioni di un $flow$ è $m$.\\
\begin{center}
    \begin{tikzpicture}[node distance={20mm}, thick , main/.style = {draw, circle}] 
    \node[main] (1) {$s$}; 
    \node[main] (2) [above right of=1] {$a$};
    \node[main] (3) [below right of=1] {$b$};
    \node[main] (4) [right of=2] {$c$};
    \node[main] (5) [right of=3] {$d$};
    \node[main] (6) [above right of=5] {$t$};
    %Admissible
    \draw[->] (1) to (2);
    \draw[->] (1) to (3);
    \draw[->] (3) to (5);
    \draw[->] (2) to (4);
    \draw[->] (5) to (6);
    \draw[->] (4) to (6);
    \draw[->] (3) to (4);
    
    %paths
    \draw[->,line width=1 pt] (1)[red, bend left] to (2);
    \draw[->,line width=1 pt] (2)[red, bend left] to (4);
    \draw[->,line width=1 pt] (4)[red, bend left] to (6);

    \draw[->,line width=1 pt] (1)[blue, bend right] to (3);
    \draw[->,line width=1 pt] (3)[blue, bend right] to (5);
    \draw[->,line width=1 pt] (5)[blue, bend right] to (6);

    \draw[->,line width=1 pt] (1)[green!70!black, bend left] to (3);
    \draw[->,line width=1 pt] (3)[green!70!black, bend left] to (4);
    \draw[->,line width=1 pt] (4)[green!70!black, bend right] to (6);

\end{tikzpicture} \\
Esempio di flow decomposto
\end{center}
Da questo grafo possiamo notare che (capacità permettendo ovviamente), un feasible flow da $s \rightarrow t$ può essere decomposto come il percorsi con \textbf{almeno un arco 
differente} che lo compongono. In particolare notiamo nel grafo:
\begin{itemize}
    \item  in \textbf{nero} il grafo del network
    \item in \textbf{\color{red}{rosso}}, \textbf{\color{green!70!black}{verde}} e \textbf{\color{blue}{blu}} tre differenti $paths$ da $s\rightarrow t$
\end{itemize}
\newpage
Un'altro passaggio fondamentale da comprendere per la risoluzione del problema il trasferimento di capacità.
\begin{definition}{Tranfer}{}
    Dato un arco $(i,j) \in E$ e un $path\ P\ i\rightarrow j$ con $|P|\ge 2$, \textbf{trasferire} $\delta$ unita di capacità da $P$ a $(i,j)$
    significa ridurre $\forall (k,l) \in P$ $u_{kl}$ di $\delta$ unità e aggiungere $\delta$ unità a $u_{ij}$ 
\end{definition}
\begin{lemma}{capacity tranfer lemma}{}
    Sia $P$ un $path$ in $G$ da $i$ a $j$ e sia $(S,T)$ un taglio. Sia $u'$ la capacità dell'arco $(i,j)$ ottenuta trasferendo $\delta$ capacità dal path $P$. Allora è vero che
    \[u'(S,T) \le u(S,T)\] 
\end{lemma}
\begin{proof}
    La dimostrazione è banale se $i,j \in S \lor i,j \in T$ dato che $u'(P) \le u(P) \implies u'(S,T)\le u(S,T)$.\\
    Mentre invece se $i\in S \land j \in T$, se consideriamo $k \in P$ il primo nodo di $P$ in $T$ e $l \in P$ il nodo subito precedente a $k$, possiamo stimare 
    \[u'(S,T)-u(S,T)\le (u'_{kl}+u'_{ij})- (u_{kl}+u_{ij}) = -\delta + \delta = 0\]\QED
\end{proof}


\[\begin{tabular}{c|c}
    \begin{tikzpicture}[node distance={15mm}, thick , main/.style = {draw, circle}] 
    % Disegna i nodi del grafo
    
    \node[main] (1) {i};
    \node[main] (0) [above left of = 1] {$s$};
    \node[main] (2) [above right of=1] {$2$};
    \node[main] (3) [below right of=1] {$j$};
    \node[main] (4) [right of=2] {$4$};
    \node[main] (6) [below right of=4] {$6$};
    \node[main] (5) [below of=4] {$5$};
    % Disegna gli archi orientati
    \draw[->] (0) to (1);
    \draw[->,line width=1.5 pt] (1)[red, bend left] to (2);
    \draw[->,line width=1.5 pt] (1)[green!80!black, bend right] to (3);
    \draw[->,line width=1.5 pt] (2)[red, bend left] to (4);
    \draw[->,line width=1.5 pt] (4)[red,bend left] to (5);
    \draw[->] (4)[bend left] to (6);
    \draw[->] (3)[bend right = 50] to (6);
    \draw[->,line width=1.5 pt] (5)[red,bend left] to (3);

    % Aggiungi una linea tratteggiata per dividere il grafo in due
    \draw[dashed] (1.7,-2) -- (1.7,2);
    \node at (1.7,2.2) {s-t\ cut};

\end{tikzpicture}& 
\begin{tikzpicture}[node distance={15mm}, thick , main/.style = {draw, circle}] 
    % Disegna i nodi del grafo
    
    
    \node[main] (0) {$s$};
    \node[main] (1) [below right of = 0] {i};
    \node[main] (2) [above right of=0] {$2$};
    \node[main] (4) [right of=2] {$4$};
    \node[main] (6) [below right of=4] {$6$};
    \node[main] (3) [below left of=6] {$j$};
    % Disegna gli archi orientati
    \draw[->] (0)[bend right] to (1);
    \draw[->,line width=1.5 pt] (1)[red, bend left] to (2);
    \draw[->,line width=1.5 pt] (1)[green!80!black, bend right] to (3);
    \draw[->,line width=1.5 pt] (2)[red, bend left] to (4);
    \draw[->,line width=1.5 pt] (4)[red, bend left] to (3);
    
    \draw[->] (4)[bend left] to (6);
    \draw[->] (3)[bend right] to (6);


    % Aggiungi una linea tratteggiata per dividere il grafo in due
    \draw[dashed] (1.7,-2) -- (1.7,2);
    \node at (1.7,2.2) {s-t\ cut};

\end{tikzpicture}\\
    \multicolumn{2}{c}{in {\color{red}{rosso}} il path P, in {\color{green!80!black}{verde}} l'arco (i,j)}
 


\end{tabular}\]

Possiamo dire in generale quindi che trasferire capacità non aumenta il max flow instradabile in un network.

\newpage
\section{Distance based}
\begin{definition}[label = VDL]{Valid distance labeling}{}
    Siano $N = (G,u)$ un Network, $f$ un feasible flow su $N$ e $l((u,v))$ una funzione che sancisce \textit{lunghezza} di ogni arco in $G$.\\
    La funzione di \textbf{distanza} $d: N(G) \rightarrow \mathbb{N}$ rispetto al \textbf{residual graph}
    $G(f)$  si dice \textbf{valida} se soddisfa le seguenti proprietà:
    \begin{enumerate}
        \item $d(t) = 0$
        \item $d(i) \le d(j) + l((i,j))$
    \end{enumerate}
\end{definition}
\textbf{Nota:} Se non diversamente specificato, una funzione $l((u,v))$ associa ad ogni arco del grafo la lunghezza $1$,
 tuttavia può anche essere specificata, come nel caso dell'algoritmo di \textbf{Goldberg-Rao}(che segue),
una funzione di lunghezza diversa. 
\begin{obs}{Valid distance label property}{}
    Una valid distance label, $d$, preserva le seguenti proprietà:
    \begin{enumerate}
        \item $d(i)$ rappresenta il \textit{lower bound} della lunghezza dello shortest directed path da $i \rightarrow t$
        nel residual graph
        \item $d(s) \ge n \implies \nexists p\ path \in G(f) | p = s \rightarrow t $ %va spegato meglio la notazione di grafo residuo e di path
    \end{enumerate}
    
\end{obs}
Un altro significato (forse l'idea di fondo) della distance labeling sta in \[\neg (d(v) > d(w) + l(v,w))\]
Ovvero, se $w,v \in N \land (v,w) \in E$ allora la distanza di $v$ non può mai superare la distanza di $w$ più la lunghezza tra i due nuovi, 
proprio per definizione di shortest path.

\begin{definition}[label = AdmissibleGraph]{Admissible graph}{}
    Siano $N = (G,u)$ un Network $N = (G,u)$ con un feasible flow $f$, $d: N(G(f)) \rightarrow \mathbb{N}$ valid distance label 
    e $l((u,v))$ una length function.
    un \textit{residual arc} si dice \textbf{Admissible arc} se soddisfa:
    \[d(v) = d(w) + l(v,w) \quad \forall (v,w) \in E(G(f))\]
    ovvero:
    \[d(v) > d(w) \lor (d(v) = d(w) \land l(v,w) = 0)\]
    
    $A(f,l,d)$ rappresenta l'\textbf{Admissible graph}, ovvero il grafo formato da tutti gli Admissible arc, rispetto alla distanza $d$ con lunghezze $l$ 
    sul residual graph dato dal flow $f$.
\end{definition}


\begin{obs}{}{}
    Sia $G(f)$ un grafo residuo, sia $B_s$ un'arborescenza data da una BFS sul grafo $G(f)$ dal nodo $s$ e sia $A$ l'\textit{admissible graph} allora
    \[E(B_s)\subsetneq E(A)\]
\end{obs}

\[
    \begin{array}{c|c|c}
        
    
    \begin{tikzpicture}[node distance={12mm}, thick , main/.style = {draw, circle}] 
    \node[main] (1) {$s$}; 
    \node[main] (2) [above right of=1] {$a$};
    \node[main] (3) [below right of=1] {$b$};
    \node[main] (4) [right of=2] {$c$};
    \node[main] (5) [right of=3] {$d$};
    \node[main] (6) [above right of=5] {$t$};
    %Admissible
    \draw[->] (1) to (2);
    \draw[->] (1) to (3);
    \draw[->] (3) to (5);
    \draw[->] (2) to (4);
    \draw[->] (5) to (6);
    \draw[->] (4) to (6);
    \draw[->] (3) to (4);
    \draw[->] (4) to (5);
    \draw[->] (5) to (2);
    \draw[->] (2) to (3);
\end{tikzpicture}  &
\begin{tikzpicture}[node distance={12mm}, thick , main/.style = {draw, circle}] 
    \node[main] (1) {$0$}; 
    \node[main] (2) [above right of=1] {$1$};
    \node[main] (3) [below right of=1] {$1$};
    \node[main] (4) [right of=2] {$2$};
    \node[main] (5) [right of=3] {$2$};
    \node[main] (6) [above right of=5] {$3$};
    %Admissible
    \draw[->, red] (1) to (2);
    \draw[->, red] (1) to (3);
    \draw[->, red] (3) to (5);
    \draw[->, red] (5) to (6);
    \draw[->, red] (3) to (4);
\end{tikzpicture} &
\begin{tikzpicture}[node distance={12mm}, thick , main/.style = {draw, circle}] 
    \node[main] (1) {$s$}; 
    \node[main] (2) [above right of=1] {$a$};
    \node[main] (3) [below right of=1] {$b$};
    \node[main] (4) [right of=2] {$c$};
    \node[main] (5) [right of=3] {$d$};
    \node[main] (6) [above right of=5] {$t$};
    %Admissible
    \draw[->] (1) to (2);
    \draw[->] (1) to (3);
    \draw[->] (3) to (5);
    \draw[->] (5) to (6);
    \draw[->] (3) to (4);
    \draw[->] (2) to (4);
    \draw[->] (4) to (6);
\end{tikzpicture} \\
\text{grafo originale}&\text{arborescenza} & \text{Admissible graph}
\end{array} 
\]
Ora che sono state definite le valid distance label, possiamo richiamare gli $s-t\ cut$ per definire i \textbf{canonical cuts}.
\begin{definition}[label = cancut]{Canonical cut}{}
    Dato un Network $\mc{N}$, e una distance label $d$ su $\mc{N}$, si definisce taglio canonico una partizione dei nodi del grafo 
    \[(S_k, T_k) =  (S_k:=\{v\in V(\mc{N}) | d(v) \ge k\},\ T_k := V(\mc{N})\setminus S_k)\]
\end{definition}
\section{Dynamics Trees}
    Questa sezione è necessaria per la comprensione della dimostrazione del costo computazionale dell'algoritmo di Orlin per il max flow in $O(nm)$.
    \subsection*{Binary search tree}
    \begin{definition}{Binary search tree}{}
        Sia $T$ un albero binario di ricerca.
        Allora T è un albero binario con la seguente proprietà
        \[\forall t \in T,\]\[ (t.key() \ge t.left().key() \lor t.left() == null)\land \]\[ (t.key() < t.right().key()\lor t.right() == null) \]
    \end{definition}
    così definite le operazioni di ricerca, minimo e massimo sono banali e in $O(\log(n))$
    
    \textbf{Succ(t)} 
    \begin{lstlisting}[style=customcpp]
    Node* Successor(x){ 
        if (x->right!=NULL) 
            return min(x->right); 
        Node* y=x->parent; 
        while (y!=NULL && x==y->right){ 
            x=y; 
            y=x->parent; 
        } 
        return y; 
    }
    \end{lstlisting}
    Se esiste un figlio destro di $t$ allora restituisco il suo min, altrimenti cerco iterativamente un padre di cui sia figlio sinistro e ritorno lui, se non esiste ritorno NULL.
    \subsection*{Splay tree}
    Una versione particolare di un BST è lo splay tree che ha la particolarità di \textit{ruotare} l'albero in modo che l'ultimo nodo visitato venga posto come radice dell'albero.
    Ovviamente la rotazione preserva l'ordinamento dell'albero che quindi è ancora interrogabili con le stesse operazioni del BST.
    In questo modo accessi multipli ad un nodo in particolare, o successivamente al suo subtree, vengono velocizzati. Il costo ammortizzato per questa struttura è di $log(n)$, la struttura è definita online, dunque una sequenza di istruzioni $m > n$ hanno costo $m\log n$.
    Lo splay avviene tramite la composizione di 3 rotazioni base (e le relative specchiate).
    \subsubsection*{Zig}
    La rotazione base:
    \[
    \begin{array}{ccc}
        splay(x)&&splay(z)\\
        \\
        
\begin{tikzpicture}[node distance={12mm}, thick , main/.style = {draw, circle, yshift=-0.8cm}, trg/.style = {draw, regular polygon, regular polygon sides=3, yshift=-0.8cm, inner sep=0pt, minimum size=1.4cm}] 
    

    \node[main] (0) {$z$}; 
    \node[main] (1) [below left of=0] {$x$};
    \node[trg] (2) [below left of=1] {$a$};
    \node[trg] (3) [below right of=1] {$b$};
    \node[trg] (4) [below right of=0 ] {$c$};
    
    %Admissible
    \draw[->] (0) to (1);
    \draw[->] (0) to (4);
    \draw[->] (1) to (3);
    \draw[->] (1) to (2);
\end{tikzpicture} &
\begin{tikzpicture}[node distance={12mm}, thick , main/.style = {draw, circle, yshift=-0.8cm}, trg/.style = {draw, regular polygon, regular polygon sides=3, yshift=-0.8cm, inner sep=0pt, minimum size=1.4cm}] 
    

    \node (0) {$\rightleftarrows$};
    \node (1) at (0,-2) {};
\end{tikzpicture} &
\begin{tikzpicture}[node distance={12mm}, thick , main/.style = {draw, circle, yshift=-0.8cm}, trg/.style = {draw, regular polygon, regular polygon sides=3, yshift=-0.8cm, inner sep=0pt, minimum size=1.4cm}] 
    \node[main] (0) {$x$}; 
    \node[main] (1) [below right of=0] {$z$};
    \node[trg] (2) [below left of=0] {$a$};
    \node[trg] (3) [below left of=1] {$b$};
    \node[trg] (4) [below right of=1 ] {$c$};
    
    %Admissible
    \draw[->] (0) to (1);
    \draw[->] (0) to (2);
    \draw[->] (1) to (3);
    \draw[->] (1) to (4);
\end{tikzpicture}
\end{array} 
\]
    
\subsubsection*{Zig-Zig}
Il caso in cui il nodo è figlio destro di un nodo figlio destro o figlio sinistro di un nodo figlio sinistro:
\[
    \begin{array}{ccc}
        splay(x)&&splay(z)\\
        \\
        
\begin{tikzpicture}[node distance={12mm}, thick , main/.style = {draw, circle, yshift=-0.8cm}, trg/.style = {draw, regular polygon, regular polygon sides=3, yshift=-0.8cm, inner sep=0pt, minimum size=1.4cm}] 
    

    \node[main] (0) {$x$}; 
    \node[main] (1) [below left of=0] {$y$};
    \node[main] (2) [below left of=1] {$z$};
    \node[trg] (3) [below right of=1] {$c$};
    \node[trg] (4) [below right of=0 ] {$d$};
    \node[trg] (5) [below right of=2 ] {$b$};
    \node[trg] (6) [below left of = 2] {$a$};
    
    
    %Admissible
    \draw[->] (0) to (1);
    \draw[->] (0) to (4);
    \draw[->] (1) to (3);
    \draw[->] (1) to (2);
    \draw[->] (2) to (5);
    \draw[->] (2) to (6);
    
\end{tikzpicture} &
\begin{tikzpicture}[node distance={12mm}, thick , main/.style = {draw, circle, yshift=-0.8cm}, trg/.style = {draw, regular polygon, regular polygon sides=3, yshift=-0.8cm, inner sep=0pt, minimum size=1.4cm}] 
    

    \node (0) {$\rightleftarrows$};
    \node (1) at (0,-2) {};
\end{tikzpicture} &
\begin{tikzpicture}[node distance={12mm}, thick , main/.style = {draw, circle, yshift=-0.8cm}, trg/.style = {draw, regular polygon, regular polygon sides=3, yshift=-0.8cm, inner sep=0pt, minimum size=1.4cm}] 
    \node[main] (0) {$z$}; 
    \node[main] (1) [below right of=0] {$y$};
    \node[main] (2) [below right of=1] {$x$};
    \node[trg] (3) [below left of=1] {$b$};
    \node[trg] (4) [below left of=2 ] {$c$};
    \node[trg] (5) [below right of=2 ] {$d$};
    \node[trg] (6) [below left of = 0] {$a$};
    
    
    %Admissible
    \draw[->] (0) to (6);
    \draw[->] (0) to (1);
    \draw[->] (1) to (3);
    \draw[->] (1) to (2);
    \draw[->] (2) to (4);
    \draw[->] (2) to (5);
\end{tikzpicture}
\end{array} 
\]

\newpage

\chapter{Past Algorithm}
\section{Dinic's Algorithm}
\label{dnc}
L'algoritmo segue l'\href{https://en.wikipedia.org/wiki/Edmonds%E2%80%93Karp_algorithm}{Edmonds-Karp} ma ragionando sul fatto che ogni volta che eseguo una BFS creo un albero di copertura con \underline{livelli} che indicano la distanza dal nodo di partenza.
quindi invece di eseguire una BFS e poi saturare solo uno dei percorsi minimi trovati, posso saturarli tutti prima di eseguire di nuovo una BFS.\\
Ogni volta che si esegue una BFS dalla \textit{source} si entra nella \textbf{blocking flow phase}.\\
\begin{definition}{Blocking flow}{}
    Per \textbf{blocking flow} si intende un flusso su un grafo (in questo caso il residuo del level graph) che satura almeno un arco per ogni possibile \textit{path} da $s\rightarrow t$.    
\end{definition}
\begin{obs}{Max flow $\implies$ blocking flow}{}
    Il max flow è un blocking flow ma non è vera l'implicazione opposta.
\end{obs}
per \textbf{level graph} si intende l'albero di copertura dato da una BFS che riporta per ogni nodo la distanza dalla radice, dividendo così il grafo in livelli.
\begin{center}
    \includegraphics[height=5.25cm]{images/levelGraph.png}\\
    \textit{source: \href{https://www.youtube.com/watch?v=M6cm8UeeziI&t=2s}{Dinic's Algorithm by WilliamFriset}}
\end{center}
In questo modo si riduce il costo dell'algoritmo da $O(n^2m)$ per Edmonds Karp a $O(nm^2)$
\paragraph{Altri link utili}\begin{enumerate}
    \item \href{http://courses.csail.mit.edu/6.854/16/Notes/n10-blocking_flows.html}{Lecture from MIT}
    \item \href{https://en.wikipedia.org/wiki/Dinic%27s_algorithm}{Wikipedia}
\end{enumerate}
\newpage

\section{Goldberg-Rao}
\label{gbr}
Ottimizzando il \nameref{dnc}, l'algoritmo di Goldberg-Rao riesce ad ottenere un \textbf{costo computazionale} di $\tilde{O}(\min\{n^{2/3}, m^{1/2}\} \cdot m)$ \\(ovvero $O(\min\{n^{2/3}, m^{1/2}\} \cdot m \cdot \log n \cdot \log nU )$)
su un Network a con capacità intera.
\paragraph*{Dettagli di notazione:}
Nella sezione 2.2 useremo la segue notazione:
\begin{itemize}
    \item $\Lambda = \min\{n^{2/3}, m^{1/2}\}$
\end{itemize}

\subsection{Idea}
    \subparagraph{}
    Alla base dell' ottimizzazione c'è l'idea di \textbf{contrarre} il Network secondo certi specifici parametri.
    L'algoritmo si basa su \nameref{VDL} e introduce una nuova \textbf{length function} \underline{binaria}: $\bar{l}((v,w)): E\rightarrow \{0,1\}$.\\
    La nuova length function assegna valore zero a tutti gli archi che soddisfano certi requisiti di capacità (che descriveremo meglio in seguito).
    \subparagraph{}
    Azzerare la lunghezza degli archi che collegano due o più nodi ci permette di considerarli come un unico nodo. 
    Dunque contraendo le componenti connesse da archi di lunghezza 0 è possibile ridurre in maniera significativa il numero di incrementi di flusso e quindi il costo computazionale dell'algoritmo.

\subsection{Il parametro $\Delta$}
    \subparagraph{}
    Il problema di contrarre il grafo consiste nel fatto che quando immettiamo il flow dalla sorgente al pozzo dobbiamo essere sicuri che tale flow rispetti i vincoli di capacità degli archi originali che ora sono contratti.
    Per assicurarci che i vincoli vengano rispettati si utilizza una certa quantità $\Delta$ che funge da \textit{upper bound} all'incremento di flow e da \textit{lower bound} alla capacità degli archi \textit{zero-length}. 
    \subparagraph{}
    Incrementando il flusso di al massimo $\Delta$ siamo sicuri di rispettare i vincoli di capacità ma non siamo più sicuri che il flusso sia bloccante.
    Dunque dobbiamo scegliere il valore da dare a $\Delta$ in maniera tale che il numero di incrementi sia ragionevolmente piccolo in modo da garantirci il costo computazionale desiderato.

\subsection{Stopping condition}
    L'algoritmo termina quando la differenza tra il flow corrente e quello massimo raggiungibile $F$ diventa minore di 1.
    Dato che le capacità del Network sono tutte intere ciò ci assicura di aver raggiunto il massimo flusso possibile.
    Un primo valore utile per $F$ corrisponde a $F = n\cdot U_{max}$

\subsection{Scheletro dell'algoritmo}
    Possiamo ora descrivere uno scheletro dell'algoritmo come segue:
    \begin{algo}{Goldberg-Rao}{}
        while $F \ge 1$:\begin{enumerate}
            \item Aggiorna il bound $\Delta$, la length function $\bar{l}$, la distance labels $d_{\bar{l}}$;
            \item Contrai i componenti fortemente connessi di archi \textit{zero-length}
            \item Determina l'Admissible graph $A(f, \bar{l},d_{\bar{l}} )$
            \item Trova un flusso in $A(f, \bar{l},d_{\bar{l}} )$ che sia bloccante o di valore $\Delta$
            \item Somma il nuovo flusso trovato con quello ottenuto fin'ora 
            \item Aggiorna il valore di $F$
        \end{enumerate}
        Ritorna il flusso finale 
    \end{algo}
    \textit{NOTA:} Il punto 4 fa riferimento al modo di trovare un flusso bloccante come nel \nameref{dnc}, ciò procedere per incrementi sugli shortest path finché non si raggiunge un flusso bloccante o di valore $\Delta$.
\subsection{Stimare il residual flow}
    Sappiamo già che la capacità residua di ogni taglio $r(S,T)$ rappresenta un \textit{upper bound} al max flow.
    Per stimare il flow residuo molto rapidamente e efficacemente possiamo analizzare i \nameref{cancut}.

    \begin{lemma}{min $r(S_k,T_k)$ in $O(m)$ time}{}
        Il taglio canonico di capacità minima può essere trovato in tempo $O(m)$
    \end{lemma}
    \begin{proof}
        Sfruttiamo il fatto che ogni arco ha lunghezza al massimo $1$, dunque può attraversare al massimo un taglio canonico.
        \begin{itemize}[noitemsep]
            \item Inizializziamo a zero ogni $r(S_k,T_k)$
            \item per ogni $(v,w) \in V$:
            \begin{itemize}
                \item se $d(v) > d(w)$: $r(S_k,T_k) += r(v,w)$
            \end{itemize}
            \item $return\ \min r(S_k,T_k)$
        \end{itemize}
        La correttezza e il costo computazionale di questa routine è piuttosto immediato
    \end{proof}
    Per gestire il costo computazionale bisogna assicurarsi che il valore di $F$ scenda abbastanza in fretta senza appesantire l'algoritmo.\\
    Possiamo raggruppare tutte le iterazioni dell'algoritmo in \textbf{fasi} e aggiornare il valore di $F$ al taglio canonico minimo solo all'inizio di una nuova fase. 
    Ogni fase parte da quando aggiorniamo il valore di $F$ fino a quando\\$\min r(S_k,T_k)\le F/2$.\\
    In questo modo dopo al massimo $\log nU_{max}$ fasi l'algoritmo termina
\subsection{Binary length function}
    Il metodo del blocking flow del Goldberg-Rao riprende da quello di Dinics con importanti modifiche per assicurarsi che: 
    \begin{itemize}[nolistsep]
        \item Il flusso aumenti in maniera significativa ad ogni iterazione 
        \item Dopo ogni raggiungimento di flusso bloccante, la distanza tra $s$ e $t$ aumenti.
    \end{itemize} 
    Allo scopo di raggiungere il costo computazionale desiderato.

    \subparagraph*{} Come già accennato abbiamo bisogno di un upper bound $\Delta$ per rispettare i vincoli di capacità, ma abbiamo anche bisogno che gli incrementi di flussi non bloccanti siano al massimo $\Lambda$ dunque possiamo inizializzare:
    \[\Delta= \lceil F/\Lambda \rceil \]
    La funzione binaria di base è la seguente:
    \[l(u.w) = \left \{ \begin{array}{ll}
        0 & r_{vw} \ge 3\Delta\\
        1 & altrimenti
    \end{array} \right .\]
    dunque archi con larga capacità avranno distanza zero. Tuttavia per raggiungere il costo desiderato è necessario apportare una modifica a tale funzione.
    \begin{definition}{Special Arc}{}
        Un arco $(v,w)$ si dice \textbf{speciale} se soddisfa tutti i seguenti requisiti:
        \begin{itemize}
            \item $2\Delta \le r_{v,w} < 3\Delta$
            \item $d(v) = d(w)$
            \item $r_{wv} \ge 3\Delta$
        \end{itemize}
    \end{definition}    
    La funzione modificata prende in considerazione anche gli archi binari:
    \[\bar{l}(u.w) = \left \{ \begin{array}{ll}
        0 & r_{vw} \ge 3\Delta \lor specialArc((v,w))\\
        1 & altrimenti
    \end{array} \right .\]
\textit{NOTA: Introdurre gli specialArc non modifica la distance labeling: $d_l = d_{\bar{l}}$}

    \begin{lemma}[label = fixCont]{Da contratto a originale}{}
        
        Supponiamo di avere contratto il Network originale come descritto fin'ora, e di aver instradato un flusso $f$ attraverso il grafo contratto.
        \paragraph*{}
        Il costo computazionale di adattare questo flusso attraverso il grafo originale è $O(m)$
    \end{lemma}
    \begin{proof}\begin{enumerate}[nolistsep]
        \item Scegliamo un vertice qualsiasi in ogni componente contratta.
        \item Formiamo un in-tree e un out-tree da con radice nei vertici scelti. 
        \item Dall'in-tree instradiamo il flusso positivo fino alla radice 
        \item Dall'out-tree riconvogliamo il flusso in entrata dalla radice a tutti altri nodi connessi.
    \end{enumerate}
    Dato che il flusso massimo che instradiamo è $\Delta$ e tutti i nodi nei componenti contratti hanno costo almeno $2\Delta$ siamo sicuri che il flusso rispetti le capacità del Network.
    Risulta immediato che tale metodo abbia costo direttamente proporzionale al numero di archi nei componenti connessi.
    \QED
    \end{proof}

    \paragraph*{}Nel Dinic's Algorithm la dimostrazione che il flusso bloccante aumenti strettamente la distanza tra $s$ e $t$ è piuttosto scontata.
    Non si può dire la stessa cosa nel caso del Goldberg-Rao data la presenza di archi di lunghezza zero. Pertanto risulta essenziale la dimostrazione del seguente teorema per assicurarsi che l'algoritmo termini.
    \begin{theo}{Blocking flow with binary length}{}
        Sia $\bar{f}$ un flow in $A(f,\bar{l}, d_l)$, sia $f' = f + \bar{f}$ il flow incrementato e sia 
        $l'$  la length function corrispondente a $f'$. Allora:
        \begin{enumerate}
            \item $d_l$ è una distance lebeling rispetto a $l'$
            \item $d_{l'}(s) \ge d_l(s)$
            \item  se $\bar{f}$ è bloccante $\implies$ $d_{l'}(s) > d_l(s)$
        \end{enumerate}
    \end{theo}
    \begin{proof}
        \textbf{\underline{1. $d_l$ è una distance lebeling rispetto a $l'$}}
            Per definizione di distance labeling $d_l(v) \le d_l(w) + \bar{l}(v,w)$ (ricordando che $d_l = d_{\bar{l}}$) 
            dobbiamo quindi dimostrare che  $d_l(v) \le d_l(w) + l'(v,w)$.\\
            Questo ciò è banalmente vero se $d_l(v) \le d_l(w)$.\\
            Se $d_l(v) > d_l(w)$ ovvero $d_{\bar{l}}(v) > d_{\bar{l}}(w)$ allora $(w,v)$ non è ammissibile rispetto a $\bar{l}$.\\
            Dunque se $(v,w)$ è ammissibile sappiamo che $u_{f'}(v,w)\le u_{f}(v,w)$ il che implica che \colorbox{yellow!40!white}{$l'(v,w)\ge \bar{l}(v,w)$} da cui segue lo statement.

            \paragraph*{\underline{2. $d_{l'}(s) \ge d_l(s)$}}

            Dimostriamo che il se $L:= {l_0, l_1, ..., l_n}$ l'insieme ordinato di tutte le funzioni di lunghezza
            calcolate tra le iterazioni dell'algoritmo allora per qualsiasi $0 \le i \le j \le n \implies d_{l_i}(s) \le d_{l_j}(s)$.\\
            Distinguiamo le due iterazioni come:
            \begin{itemize}
                \item Nell'iterazione $i$\\
                Sia $l(u,v) = l_i(u,v)$ la funzione di lunghezza e $d(x) = d_{l_i}(x)$ quella di distanza, insieme al flusso definiscono $A(f, l_i, d_{l_i})$.\\ Sia $\Gamma$ l'$s\rightarrow t$ shortest path in $A: \Gamma \subseteq A$
                \item Nell'iterazione $j$\\
                Sia $l'(u,v) = l_j(u,v)$ la funzione di lunghezza e $d'(x) = d_{l_j}(x)$ quella di distanza, insieme al flusso definiscono $A'(f, l_j, d_{l_j})$.\\ Sia $\Gamma'$ l'$s\rightarrow t$ shortest path in $A': \Gamma' \subseteq A'$
            \end{itemize}
            
            Supponiamo per assurdo che esistano due iterazioni $0 \le i\le j :$\\$ d(s) > d'(s)$:
            \[\implies \exists \Gamma s\rightarrow t,\ \Gamma ' \ s \rightarrow t : \sum_{(v,w)\in \Gamma} l(v,w) \ge \sum_{(v,w)\in \Gamma'} l'(v,w)\]
            Ovvero andando avanti con le iterazioni $s$ e $t$ si sono avvicinati.\\
            Escludiamo subito il caso in cui $\Gamma = \Gamma'$ in quanto
            \[\forall (v,w)\in A\cap A',\  l(v,w) \le l'(v,w)\implies l(\Gamma)\ \le\ l'(\Gamma')\]
            \begin{center}
                \textit{NOTA: $l(\Gamma) = \sum_{(v,w)\in \Gamma} l(v,w)$}
            \end{center}
            Consideriamo ora $\Gamma$ e $\Gamma'$. Sia $w$ l'ultimo nodo in $\Gamma$ per cui è vero che $d(w)> d'(w)$ e sia $x$ il nodo che lo segue:
            \[w \in \Gamma : d(w) > d'(w) \land \exists x = succ_\Gamma(w) : d(x)\le d'(x)\]
            $w$ e $x$ sono sempre ben definiti perché $d(s)>d'(s)$ per ipotesi e $d(t) = d'(t) = 0$ per definizione.
            Dunque esiste in $\Gamma'$ un arco $(w,y)$ con $y \not = x$ tale che $d'(y) < d'(x)$. $x \not = y$ perché se fossero lo stesso nodo allora \[d'(w) = d'(x) + l'(w,x)\ge d(w)\]
                che contraddice le ipotesi\\
            Ricomponendo il tutto, sappiamo che:
            \begin{enumerate}
                \item $d(w)>d'(w) \iff d(x) + l(w,x) > d'(y) + l'(w,y)$ \\Non conosciamo la distanza $d(y)$ ma sappiamo che:
                \[d'(y) = \sum_{(a,b)\in y-t\subseteq \Gamma'}l'(a,b) \ge \sum_{(a,b)\in y-t\subseteq \Gamma'}l(a,b) \]
                Quindi il percorso all'iterazione $j$ è maggiore o uguale a quello dell'iterazione $i$.
                \item $d(y) +l(w,y) \le d'(y) +l'(w,y) < d(x) +l(w,x)$  
            \end{enumerate}
            Ma noi sappiamo che $d(w) = d(x) +l(w,x)$ il che è \textbf{assurdo} perché non è la distanza minima di $w\rightarrow t$ in quanto è maggiore di 
            $d(y) +l(w,y)$. 
            
            Sappiamo per certo che il percorso $w-y\rightarrow t$ esiste in $A$ proprio perché (a meno che non ne esista uno più corto) rappresenta il percorso con distanza minima da $w\rightarrow t$.

            Dall'assurdo, le uniche conclusioni sono che o il percorso che passa per $y$ non era raggiungibile all'iterazione $i$ e quindi è impossibile raggiungerlo successivamente, 
            oppure se esiste un percorso $s\rightarrow t$ all'iterazione $j$ minore di quello all'iterazione $i$, abbiamo sbagliato a considerare quello all'iterazione $i$.

        
            \paragraph*{\underline{3. Se $\bar{f}$ è bloccante allora $d_l(s) < d_{l'}(s)$}}

            Per mostrare che il flow bloccante aumenta la distanza del nodo $s$ definiamo il la seguente dicitura:
            \[c(v,w):= d_l(w)-d_l(v) + l'(v,w)\]
            che rappresenta il cambiamento di lunghezza di un arco che collega due nodi adiacenti.
            Possiamo affermare che:
            \[\forall (v,w)\in E,\ c(v,w)\ge 0\]
            dato che $l'(v,w)\ge l(v,w)\implies$
            \[ d_l(w)-d_l(v) < 0 \iff l(v,w) = 1 \implies l'(v,w) = 1\]
            Consideriamo ora un qualsiasi percorso $\Gamma$ in $G_{f'}$, la lunghezza del percorso è uguale a: 
            \[l'(\Gamma) = d_l(s)+c(\Gamma)\]
            Per mostrare quindi che il percorso è più lungo basta mostrare che 
            \[\forall shortest\ s-t\ path\ \Gamma \in G_{f'}\implies \exists (v,w)\in \Gamma | c(v,w) > 0\]
            Abbiamo ora uno strumento per mostrare che il flusso bloccante aumenta la distanza di $s$.

            \begin{example}{}{}

            \begin{tabular}{c|c}
                \multicolumn{2}{c}{Un semplice esempio grafico per visualizzare meglio quanto dichiarato}\\
                \\
                \begin{tikzpicture}[node distance={14mm}, thick , main/.style = {draw, circle}] 
                \node[main] (1) at (0,0) {$s$}; 
                \node[main] (2) [above right of=1] {$2$};
                \node[main] (3) [right of=2] {$3$};
                \node[main] (4) [right of=3] {$4$};
                \node[main] (5) [below right of=1] {$5$};
                \node[main] (6) [right of=5] {$6$};
                \node[main] (7) [right of=6] {$7$};
                \node[main] (9) [below right of=4] {$t$};
                \node[main] (8) at ($(1)!0.5!(9)$) {$8$};
                %Admissible
                \draw[->] (1) to (2);
                \draw[-] (2) to [red, midway] node {Full} (3);
                \draw[-] (3) to (4);
                \draw[-] (4) to (9);
                \draw[-] (3) to (8);
                \draw[-] (2) to (8);
                \draw[-] (8) to (7);
                \draw[->] (1) to (5);
                \draw[-] (5) to (6);
                \draw[-] (6) to (7);
                \draw[-] (7) to [red, midway] node {Full} (9);
                
                %paths
                \draw[->,line width=1 pt] (1)[babyblue, bend left] to (2);
                \draw[->,line width=1 pt] (2)[babyblue, bend left] to (3);
                \draw[->,line width=1 pt] (3)[babyblue, bend left] to (4);
                \draw[->,line width=1 pt] (4)[babyblue, bend left] to (9);
            
                \draw[->,line width=1 pt] (1)[blue, bend right] to (5);
                \draw[->,line width=1 pt] (5)[blue, bend right] to (6);
                \draw[->,line width=1 pt] (6)[blue, bend right] to (7);
                \draw[->,line width=1 pt] (7)[blue, bend right] to (9);

            
            \end{tikzpicture} 
            &
            \begin{tikzpicture}[node distance={14mm}, thick , main/.style = {draw, circle}] 
                \node[main] (1) at (0,0) {$s$}; 
                \node[main] (2) [above right of=1] {$2$};
                \node[main] (3) [right of=2] {$3$};
                \node[main] (4) [right of=3] {$4$};
                \node[main] (5) [below right of=1] {$5$};
                \node[main] (6) [right of=5] {$6$};
                \node[main] (7) [right of=6] {$7$};
                \node[main] (9) [below right of=4] {$t$};
                \node[main] (8) at ($(1)!0.5!(9)$) {$8$};
                %Admissible
                \draw[->] (1) to (2);
                \draw[-] (3) to (4);
                \draw[-] (4) to (9);
                \draw[-] (3) to (8);
                \draw[-] (2) to (8);
                \draw[-] (8) to (7);
                \draw[->] (1) to (5);
                \draw[-] (5) to (6);
                \draw[-] (6) to (7);
                
                \draw[->,line width=1 pt] (1)[brightgreen, bend left] to (2);
                \draw[->,line width=1 pt] (2)[brightgreen, bend left] to (8);
                \draw[->,line width=1 pt] (8)[brightgreen, bend right] to (3);
                \draw[->,line width=1 pt] (3)[brightgreen, bend left] to (4);
                \draw[->,line width=1 pt] (4)[brightgreen, bend left] to (9);

            \end{tikzpicture}\\
            In \textbf{\color{babyblue}{azzurro}} $f$ e in  & In \textbf{\color{brightgreen}{verde}} lo \textit{shortest path} $\Gamma$ in $G_{f'}$\\
            \textbf{\color{blue}{blu}} $\bar{f}$ in $A(f,\bar{l}, d_l)$ &
\end{tabular}
\end{example}
    Dato che $\bar{f}$ è bloccate in $A(f,\bar{l}, d_l)$, $\Gamma$ deve contenere un arco $(v,w)$ non presente in in $A(f,\bar{l}, d_l)$.
    
    Possiamo in oltre affermare che $d_l(v)\le d_l(w)$ o perché $(v,w) \in G_f$ ma allora se $d_l(v)> d_l(w)$ avremmo $(v,w) \in A(f,\bar{l}, d_l)$
    oppure perché $(v,w) \not \in G_f$ ma appare in $G_{f'}$ e ciò è possibile solo se incremento il flusso nella direzione opposta per far apparire l'arco residuo. Dunque $(w,v) \in A(f,\bar{l}, d_l)$ il che implica che $d_l(v)\le d_l(w)$.

    Supponiamo ora per assurdo che $c(v,w) = 0$, dunque $d_l(v) = d_l(w)$ e $l'(v,w) = 0$.
    Il fatto che $(v,w)$ non sia in $A(f,\bar{l}, d_l)$ implica che o $(v,w)$ non sia in $G_f$, ma allora abbiamo mostrato già che l'arco opposto $(w,v)\in A(f,\bar{l}, d_l)$, 
    oppure che $(v,w) \in G_f$ e non rispetta i requisiti di distance labeling per appartenere all'\nameref{AdmissibleGraph} $A(f,\bar{l}, d_l)$.\\
    Dato che $d_l(v) = d_l(w)$ allora $l(v,w) = 1$. Si nota $1 = l(v,w) > l'(v,w) = 0$ implica che ho incrementato il flusso sull'arco opposto $(w,v)$.\\
    Dunque in ogni caso l'arco $(w,v)\in A(f,\bar{l}, d_l)$.

    Come già mostrato in precedenza, dato che $d_l(v) = d_l(w)$, \[(w,v)\in A(f,\bar{l}, d_l) \iff l(w,v) = 0\]
    Concludiamo quindi che: 
    \begin{itemize}
        \item Durante gli incrementi di flusso abbiamo immesso un flow (di valore al massimo $\Delta$) attraverso l'arco $(w,v)$
        \item $u_f(w,v) \ge 3\Delta$ perché $l(w,v) = 0$
        \item Dopo questo incremento abbiamo: $u_{f'}(v,w) \ge 3\Delta$ perché  $l'(v,w) = 0$
        \item Quindi $u_f(v,w) \ge 2\Delta$
        \item Ma allora l'arco $(v,w)$ era un \textit{arco speciale} già prima dell'incremento, in quanto $d_l(v) = d_l(w) \land u_f(w,v) \ge 3\Delta \land u_f(v,w) \ge 2\Delta$
    \end{itemize}
    Concludiamo quindi che: 
    \[d_l(v) = d_l(w) \implies d_{\bar{l}}(v) = d_{\bar{l}}(w) \land \bar{l}(v,w) = 0 \implies (v,w) \in A(f,\bar{l}, d_l)\]
    Il che è assurdo 
    \QED
    \end{proof}
    \subsection{Costo computazionale}
    Dimostrata la correttezza del codice, segue il costo computazionale:
    \subsubsection{Costo di una fase}
    Prima di addentrarci nel costo di una fase, rivediamo la struttura dell'algoritmo descritto fino ad ora.
    \begin{verbatim}
    def Goldberg_Rao_Algorithm(Network network)
        F = U*n
        Delta = F/Lambda
        f = 0
        while F >= 1:
            l = update_length(n, Delta)
            d_l = distanceLabel(network, l)
            Gc = collapse(network)
            Ag = admissible_graph(g)
            f' = find_blocking_or_Delta_flow(Ag)
            f = f + f'
            network.fitFlow(f)
            if min_canonical_cut(network).residual() <= F/2: 
                F = min_canonical_cut(network).residual()
                Delta = F/Lambda

        return f
        
    \end{verbatim}
    \begin{remark}
        {Costo da raggiungere}{}
        Il costo dichiarato in partenza è in:
        \[O(\min \{n^{2/3}, m^{1/2}\}\cdot m \log n\log m U_{max})\]
        utilizzando strutture dati più avanzate, si può raggiungere il costo di:
        \[O(\min \{n^{2/3}, m^{1/2}\}\cdot m \log \frac{n^2}{m}\log U_{max})\]

    \end{remark}
    Abbiamo già notato che il numero di \textbf{fasi} (ovvero il numero di decrementi) di F è nell'ordine di $\log(F)$ ovvero $log(m U_{max})$.
    Il costo per calcolare il min canonical cut e per adattare il flow al network sono entrambi in $O(m)$.
    Resta però da analizzare il costo di ogni fase, cioè quanto in fretta il min canonical cut si dimezza.
    \begin{lemma}
        {}{}
        La capacità minima di un canonical cut $(\bar{S}, \bar{T})$ soddisfa
        \[u_f(\bar{S}, \bar{T})\le \frac{mM}{d_l(s)}\]
        dove M rappresenta l'arco di lunghezza uno con più capacità
    \end{lemma}
    \begin{proof}
        Risulta evidente che il il modo migliore in cui si può massimizzare la capacita del taglio canonico minimo è supponendo che tutti gli archi abbiano la capacità dell'arco di capacità maggiore e poi dividere equamente gli archi tra i vari tagli.
    \QED
    \end{proof}

    Da questa prima stima segue il corollario
    \begin{corollary}{}{}
    Durante ogni fase ci sono al massimo $O(\Lambda)$ blocking flow incrementi.
    \end{corollary}
    \begin{proof}
        Supponiamo che $\Lambda = m^{1/2}$ dato che abbiamo dimostrato che ogni blocking flow incrementa $d(s)$ di almeno uno, siamo sicuri che dopo $6\lceil \Lambda\rceil$ incrementi $d_l(s) \ge 6 m^{1/2}$.
        Dunque possiamo prendere la stima nel lemma e affermare che:
        \[ u_f(\bar{S}, \bar{T})\le \frac{mM}{d_l(s)}\le \frac{3m}{d_l(s)}\Delta\le \frac{3m}{6m^{1/2}}\frac{F}{m^{1/2}} = \frac{F}{2}\]
        Dunque dopo $\lceil \Lambda\rceil$ la fase termina.\\
        Per $\Lambda = n^{2/3}$ la dimostrazione è analoga e porta alla stessa conclusione. 
        In conclusione, il costo di ogni fase è in ordine di $O(\Lambda)$ \QED
    \end{proof}
    
    L'ultimo collo di bottiglia è rappresentato dal costo di trovare un blocking flow o di valore massimo $\Delta$ (computazionalmente equivalenti):
    il che richiederebbe un costo di:
    \begin{itemize}
        \item $O(mn)$ in un approccio naive;
        \item $O(m\log n)$ utilizzando i dynamic trees;
        \item $O(m \log(n^2/m))$ utilizzando i size-bounded dynamic trees;
    \end{itemize}
    Unendo il costo di:
    \begin{itemize}[label=$\times$]
        \item trovare un Blocking flow
        \item le iterazioni in ogni fase
        \item il numero di fasi
        \item gli ulteriori costi in $O(m)$
    \end{itemize}
    Si ottiene il tempo dichiarato.


\chapter{Orlin Algorithm}
L'algoritmo di Goldberg-Rao raggiunge un costo detto \textit{weakly polynomial}, risolvendo il problema in $\log mU$ fasi ognuna da $O(\Lambda m \log(n^2/m))$ dove $\Lambda = \min \{n^{2/3}, m^{1/2}\}$.
Se si vuole risolvere il problema del max flow con un costo di tempo che sia \textit{strongly polynomial} esiste l'algoritmo di King Rao e Tarjan. Tuttavia, tale algoritmo raggiunge un costo di $O(nm)$ solo a patto che $ m = \Omega (n^{1+\varepsilon})$ per qualche $\varepsilon > 0$. 
Se il numero di archi non è sufficiente, il suo costo è di $O(nm \log m/(n \log n) n)$.

Con il seguente algoritmo James B. Orlin propone una soluzione che sfruttando l'algoritmo di Goldberg-Rao, riesce a risolvere il problema del max flow in $O(nm)$ quando $m = O(n^{1+\varepsilon})$ rendendo così possibile risolvere il problema in tempo strettamente polinomiale per ogni valore di $n$ e $m$ e senza essere limitati da capacità di qualche arco.

\section{Idea}
L'idea nasce da varie osservazioni:
Il Goldberg-Rao lavora per \textbf{fasi di incremento} che prendono un flusso \dlt-ottimale e lo rendono $\Delta/2$-ottimale. 
In oltre si nota che $\log_{8m} mU \le 1 + \log U$ infatti d'ora in poi verranno considerate $\log U$ fasi di incremento.
Se consideriamo $\Lambda = O(m^{1/2})$ possiamo notare che \[\log U < m^{7/16} \implies \tilde{O}(m^{3/2}m^{7/16}) = \tilde{O}(m^{31/16})\] 
(la notazione $\tilde{O}$ ignora i fattori logaritmici).\\
Approfondendo il calcoli si osserva 
\[\tilde{O}(m^{31/16}) = O(m\cdot m^{15/16}\cdot log(n^2/m)) = O(m\cdot n^{(16/15)^{15/16}}\cdot log(n^2/m)) \]
dato che stiamo cercando un algoritmo per quando $m = O(n^{1+\varepsilon})$, se $1+\varepsilon < 16/15$ e $\log U < m^{7/16}$ possiamo ottenere una soluzione ottimale ad un costo polinomiale $O(nm)$ già utilizzando solo il Goldberg-Rao.

Ad ogni modo, ciò è vero solo se il numero di archi è sufficientemente più grande rispetto all'arco di capacità massima.
Da qui l'idea di contrarre e compattare il network per fare in modo di calcolare il flusso massimo nelle condizioni ottimali . 

L'algoritmo presenta due bottleneck: 
\begin{enumerate}
    \item creazione della rappresentazione compattata (più precisamente, mantenimento della chiusura trannsitiva)
    \item passaggio dal flow compattato al flow esteso.
\end{enumerate}

\section{Fase di incremento}
Il max-flow flow problem viene risolto attraverso una serie di \textit{fasi di incremento}, vediamo quindi quali sono gli input e gli output di ogni fase:
\begin{itemize}[itemsep=0.5ex]
    \item \textbf{input}
    \begin{enumerate}
        \item un \textit{Flow} $f$
        \item un \textit{Residual Graph} $G_f$, rappresentabile anche come $r: E \rightarrow \mathbb{R}$ la funzione che associa a ogni arco la sua capacità residua
        \item un s-t cut $(S,T)$
    \end{enumerate}
    Possiamo rappresentare l'input con la tripla $(r,S,T)$
    \item \textbf{output}
    \begin{enumerate}
        \item un \textit{Flow} $f'$
        \item un \textit{Residual Graph} $G_f'$
        \item un s-t cut $(S',T')$ tale che $r'(S',T') \le \frac{r(S,T)}{8m}$
    \end{enumerate}
\end{itemize}
Questa fase prende il nome di $\Delta\text{-}improvement\ phase$ dove $\Delta = r(S,T)$.
Affianco al parametro $\Delta$ verrà posto un parametro $\Gamma$ , dove $\Gamma \le \Delta$ che verrà utilizzato per creare il $\Gamma$-compact network. 

A seconda delle condizioni, il \dlt improvement verrà eseguito o sul network $G$ originale oppure sul \gmm-\textit{compact network} $G^c$ che presenteremo più avanti.

\section{$\Delta$-abundant e grafo di abbondanza}
In questa sezione viene presentato il concetto di \textbf{Abbondanza}.

\begin{definition}{$\Delta$-abundant arc}{}
    Sia $\Delta = r(S,T)$ un arco $(i,j)$ si dice $\Delta$-abbondante se $r_{ij} \ge 2\Delta$ 
     
\end{definition}
\begin{lemma}[label = ab4ever]{}{}
    
    Sia $(r,S,T)$ l'input di una $\Delta\text{-}improvement\ phase$. Se l'arco $(i,j)$ è abbondate prima dell'incremento allora rimmarrà abbondante per tutti gli incrementi successivi.
\end{lemma}
\begin{proof}
    Dato che 
    $\Delta' \le \frac{\Delta}{8m} $ e ricordando che $r_{ij} \ge 2\Delta $ si deduce che 
    allora \[r'_{ij} \ge r_{ij}-\Delta \ge\Delta\ge  2\Delta'\]\QED
\end{proof}

\begin{definition}{Grafo di Abbondanza}{}
    Dato un network $G$ si definisce il suo \textbf{grafo di abbastanza} $G^{ab}$ come: 
    \[G^{ab} := (N(G), \{(i,j)| (i,j)\in E(G)\land r_{ij}\ge 2\Delta\})\]
\end{definition}
\begin{obs}{}{}
    Per il lemma \ref{ab4ever} proseguendo con le iterazioni il grafo di abbondanza può solo acquisire nuovi archi, mai perderli.
\end{obs}

Il grafo di abbondanza ha due scopi: 
\begin{enumerate}
    \item Tutti i cicli formati da archi abbondanti vengono \textit{contratti} in un solo nodo
    \item Tutti i nodi che adiacenti solo ad archi abbondanti (o di capacità troppo piccola), vengono \textit{compattati}
\end{enumerate}
L'algoritmo mantiene in oltre la chiusura transitiva di tutti i nodi collegati tra loro da un \textbf{abundant path}, ovvero un cammino composto solo da archi abbondanti. \\
Se esiste un abundant path tra il nodi $i$ e $j$, ciò si indica con $i\implies j$, e l'informazione viene mantenuta in una matrice \textbf{M}$_{n\times n}$, dove nella posizione 
\textbf{M}$_{i,j}$ si trova il nodo che precede $j$ nel percorso che parte da $i$. Se durante le iterazioni si creano più percorsi viene comunque mantenuto il primo trovato.

La chiusura transitiva può essere mantenuta in tempo $O(nm)$ utilizzando l'algoritmo di Italiano. 
In questo modo è sempre possibile (vedremo di seguito che contrarre il grafo non lo impedisce e non ne altera il costo) ricostruire un percorso abbondante $P$ in $O(|P|)$
\newpage
\section{Contractions of abundant graph}
Vediamo ora come sfruttare l'abundant graph per contrarre il grafo su cui calcolare il max-flow e rendere l'algoritmo più efficiente.

Analizziamo tre contrazioni di esempio differenti:\\
\\
Supponiamo che esistano due nodi $i$ e $j$ tali che $r_{ij} \ge 2\Delta$ e $r_{ji} \ge 2\Delta$

Possiamo quindi contrarre i due nodi in uno unico che preservi gli archi di entrambi
\[\begin{tabular}{ccc}
    \begin{tikzpicture}[node distance={15mm}, thick , main/.style = {draw, circle}] 
    % Disegna i nodi del grafo
    

    \node[main] (0) {$s$};
    \node[main] (3) [right of= 0 ] {$i$};
    \node[main] (4) [right of=3] {$j$};
    \node[main] (1) [below of = 3 ] {3};
    \node[main] (2) [above of = 3] {$1$};
    
    \node[main] (6) [above of=4] {$2$};
    \node[main] (5) [below of=4] {$4$};
    \node[main] (7) [right of=4] {$t$};
    % Disegna gli archi orientati
    \draw[->] (0) [bend right] to (1);
    \draw[->] (0) [bend left] to (2);
    \draw[->] (0) to (3);
    \draw[->] (3) [red, bend left] to (4);
    \node at (2.25,0.5) {$2\Delta$};
    \node at (2.25,-0.5) {$2\Delta$};
    \draw[->] (4) [red, bend left] to (3);
    
    \draw[->] (2) to (6);
    \draw[->] (4)[bend left] to (1);
    \draw[->] (4)[bend right] to (6);
    \draw[->] (6)[bend right] to (3);
    \draw[->] (4) to (7);
    \draw[->] (1) to (5);
    \draw[->] (6)[bend left] to (7);
    \draw[->] (5)[bend right] to (7);


\end{tikzpicture}&\begin{tikzpicture}
    \node {$\implies$};% Freccia verso destra
    \node at (0,1.4) {};
    \node at (0,-1.6) {};
\end{tikzpicture}  &
\begin{tikzpicture}[node distance={19mm}, thick , main/.style = {draw, circle}] 
    % Disegna i nodi del grafo
    
    
    \node[main] (m)  {$i$-$j$};
    \node[main] (0) [left of = m ]{$s$};
    \node[main] (1) at (-0.8,1.45) {1};
    
    \node[main] (2) at (0.8,1.45) {$2$};

    \node[main] (3) at (-0.8,-1.45) {$3$};
    \node[main] (4) at (0.8,-1.45) {$4$};

    \node[main] (5) [right of = m] {t};
    % Disegna gli archi orientati

    
    \draw[->] (0) to (m);
    \draw[->] (0)[bend left] to (1);
    \draw[->] (0)[bend right] to (3);

    \draw[->] (1) to (2);

    \draw[->] (2)[bend right] to (m);
    \draw[->] (m)[bend right] to (2);
    \draw[->] (m)[bend left] to (3);
    \draw[->] (2)[bend left] to (5);
    \draw[->] (m) to (5);
    \draw[->] (3) to (4);  
    \draw[->] (4)[bend right] to (5);

\end{tikzpicture}
\end{tabular}\]

Dato che non esistono archi opposti agli archi esterni, è possibile contrarre archi esterni alla sola condizione che essi siano abbondanti:

\[\begin{tabular}{ccc}
    \begin{tikzpicture}[node distance={19mm}, thick , main/.style = {draw, circle}] 
    % Disegna i nodi del grafo
    
    \node[main] (0) {$s$};
    \node[main] (1) [above right of = 0] {1};
    \node[main] (2) [below right of = 0] {2};
    \node[main] (3) [right of = 1] {3};
    \node[main] (4) [right of = 2] {4};
    \node[main] (5) [below right of = 3] {$t$};
    
    \draw[->] (0) [red] to (1);
    \draw[->] (1) to (3);
    \draw[->] (0) to (2);
    \draw[->] (2) to (4);
    \draw[->] (3) to (5);
    \draw[->] (4) [red] to (5);
    \draw[->] (1) to (2);
    \draw[->] (3) to (4);

    \node at (0.4,0.9) {$2\Delta$};
    \node at (4.3,-0.9) {$2\Delta$};

\end{tikzpicture}&\begin{tikzpicture}
    \node {$\implies$};% Freccia verso destra
    \node at (0,1.4) {};
    \node at (0,-1.6) {};
\end{tikzpicture}  &
\begin{tikzpicture}[node distance={19mm}, thick , main/.style = {draw, circle}] 
    % Disegna i nodi del grafo
    \node[main] (0) {$s$-$1$};
    \node[main] (3) at (2,1.4) {$3$};
    \node[main] (2) at (2,-1.4) {$2$};
    \node[main] (4) at (4,0) {4-$t$};

    \draw[->] (0) to (3);
    \draw[->] (0) [bend left = 10] to (2);
    \draw[->] (0) [bend right = 10] to (2);
    
    
    \draw[->] (2) to (4);
    \draw[->] (3) [bend left = 10] to (4);
    \draw[->] (3) [bend right = 10] to (4);
    

\end{tikzpicture}
\end{tabular}\]

E dunque tutti i cicli abbondanti

\[\begin{tabular}{ccc}
    \begin{tikzpicture}[node distance={18mm}, thick , main/.style = {draw, circle}] 
    % Disegna i nodi del grafo
    
    \node[main] (0) {$s$};
    \node[main] (1) at (1*1.4,0) {1};
    \node[main] (2) at (2*1.4,0.577*1.4) {2};
    \node[main] (3) at (2*1.4,-0.577*1.4) {3};
    \node[main] (4) at (3*1.4,0) {$t$};
    \node[main] (5) at (1*1.4,1.154*1.4) {$5$};
    \node[main] (6) at (1*1.4,-1.154*1.4) {$6$};

    \draw[->] (0) [bend left] to (5);
    \draw[->] (0) [bend right] to (6);
    \draw[->] (0)  to (1);
    \draw[->] (1)[red]  to (2);
    \draw[->] (2)[red]  to (3);
    \draw[->] (3)[red]  to (1);
    \draw[->] (2)  to (4);
    \draw[->] (3)  to (4);
    \draw[->] (5) [bend left = 45] to (4);
    \draw[->] (6) [bend right = 45] to (4);

    \node at (3.1,0) {$2\Delta$};
    \node at (1.7,0.577*1.4) {$2\Delta$};
    \node at (1.7,-0.577*1.4) {$2\Delta$};
    

\end{tikzpicture}&\begin{tikzpicture}
    \node {$\implies$};% Freccia verso destra
    \node at (0,1.4) {};
    \node at (0,-1.6) {};
\end{tikzpicture}  &
\begin{tikzpicture}[node distance={19mm}, thick , main/.style = {draw, circle}] 
    % Disegna i nodi del grafo
    \node[main] (0) {$s$};
    \node[main] (1) at (1.5*1.4,0) {1-2-3};
    \node[main] (5) at (1.5*1.4,1.154*1.4) {$5$};
    \node[main] (6) at (1.5*1.4,-1.154*1.4) {$6$};
    \node[main] (4) at (3*1.4,0) {$t$};

    \draw[->] (0) [bend left] to (5);
    \draw[->] (5) [bend left] to (4);
    \draw[->] (0) [bend right] to (6);
    \draw[->] (6) [bend right] to (4);

    \draw[->] (0) to (1);
    \draw[->] (1) [bend left= 15] to (4);
    \draw[->] (1) [bend right = 15] to (4);

\end{tikzpicture}
\end{tabular}\]
\begin{obs}{Violazioni della conservazione del flusso}{}
    È possibile che quando il grafo contratto verrà riespanso venga violata la legge di conservazione del flusso. 
    
    Tuttavia si tratta di una violazione minore di $2\Delta$ unità dunque, come mostrato da \hyperref[fixCont]{Goldberg e Rao} la contrazione, l'espansione e l'adattamento per la conservazione del flusso possono essere eseguiti in tempo $O(m)$. 
\end{obs}
\section{Compattare il network}
Oltre alla contrazione del grafo è necessario eseguire un'altra trasformazione, la \textit{compattazione}.
Per ottenere un grafo compatto mostriamo prima come ottenere una versione intermedia ovvero lo \textbf{strongly compact network}.

\noindentÈ importante comprendere la differenza tra contrarre e compattare:

Se nella contrazione viene creato un nodo unico che rappresenta il ciclo abbondate e vengono preservati gli archi originali non appartenenti al ciclo, 
quando si compatta un grafo viene \underline{eliminato} un nodo che ha tutti gli archi adiacenti abbondanti e gli archi eliminanti di conseguenza vengono sostituiti da pseudo archi.

\[\begin{tabular}{ccc}
    \begin{tikzpicture}[node distance={18mm}, thick , main/.style = {draw, circle}] 
    % Disegna i nodi del grafo
    
    \node[main] (0) {$s$};
    \node[main] (1) at (1, 1.6) {1};
    \node[main] (2) at (1, -1.6) {2};
    \node[main] (3) at (3.5, 1.6) {3};
    \node[main] (4) at (3.5, -1.6) {4};
    \node[main] (6) at (2.25,0) {5};
    \node[main] (5) at (4.5, 0) {$t$};

    \draw[->] (0)[bend left] to (1);
    \draw[->] (0)[bend right] to (2);
    \draw[->] (1)[bend left] to (3);
    \draw[->] (2)[bend right] to (4);
    \draw[->] (4)[bend right] to (5);
    \draw[->] (3)[bend left] to (5);

    \draw[->] (1)[red, bend right] to (6);
    \draw[->] (6)[red, bend right] to (4);
    \draw[->] (6)[red, bend left] to (3);
    \draw[->] (2)[red, bend left] to (6);
    \draw[->] (6) [red] to (5);

    \node at (3.3,0.2) {$2\Delta$};
    \node at (2.3,1.2) {$2\Delta$};
    \node at (2.3,-1.2) {$2\Delta$};

    \node at (1,.7) {$2\Delta$};
    \node at (1,-.7) {$2\Delta$};
    

\end{tikzpicture}&\begin{tikzpicture}
    \node {$\implies$};% Freccia verso destra
    \node at (0,1.4) {};
    \node at (0,-1.95) {};
\end{tikzpicture}  &
\begin{tikzpicture}[node distance={19mm}, thick , main/.style = {draw, circle}] 
    % Disegna i nodi del grafo
    \node[main] (0) {$s$};
    \node[main] (1) at (1, 1.6) {1};
    \node[main] (2) at (1, -1.6) {2};
    \node[main] (3) at (3.5, 1.6) {3};
    \node[main] (4) at (3.5, -1.6) {4};
    \node[main] (5) at (4.5, 0) {$t$};

    \draw[->] (0)[bend left] to (1);
    \draw[->] (0)[bend right] to (2);
    \draw[->] (1)[bend left] to (3);
    \draw[->] (2)[bend right] to (4);
    \draw[->] (4)[bend right] to (5);
    \draw[->] (3)[bend left] to (5);

    \draw[->] (1)[red, bend right] to (3);
    \draw[->] (2)[red, bend left] to (4);
    \draw[->] (2)[red, bend left = 23] to (5);
    \draw[->] (1)[red, bend right = 23] to (5);


\end{tikzpicture}
\end{tabular}\]
 Il seguente algoritmo ha tempo $O(m + |E^{sc}|)$ in quanto si possono costruire gli pseudo archi in tempo $O(1)$ dato che viene dinamicamente preservata la chiusura transitiva. 

\begin{algo}{strongly compact network}{}
    Definiamo lo \textbf{Strongly compact} come $G^{sc} =(N^{sc}, E^{sc})$ originato dal network $G$:
    \begin{enumerate}
        \item Contrarre il grafo di tutti gli abundant cycles e degli archi esterni abbondanti.\\
        Sia $(r,S,T)$ l'input dopo la contrazione.
        \item Sia $N^{sc}\subseteq N(G)$ l'insieme dei nodi che sono adiacenti ad almeno un arco non abbondante.\\
        Ci riferiremo a $N(G)\setminus N^{sc}$ come l'insieme dei nodi \textit{strongly compactible}.
        \item Definiamo gli archi come $E^{sc} = E^1 \cup E^2$ dove:\\
        $E^1 = \{(i,j): i\in N^{sc}\land j\in N^{sc}\land (i,j)\in E(G)\}$\\
        $E^2 = \{(i,j): i\in N^{sc}\land j\in N^{sc}\land i\implies j\}$\\
        Dunque abbiamo archi originali in $E^1$ e pseudo archi che derivano dagli abundant path.
        
    \end{enumerate}
    
\end{algo}
   \begin{theo}[label = fmaxfsc]{$f_{max} = f_{max}^{sc}$}{}
    Sia $f_{max}$ il flusso massimo nel network $G$ e sia $f_{max}^{sc}$ il flusso massimo in $G^{sc}$ allora 
    \[f_{max} = f_{max}^{sc}\]
\end{theo}
\begin{proof}
    Abbiamo già mostrato che qualsiasi flow in $G^{sc}$ può essere reindirizzato in $G$.
    Se invece prendiamo un flow in $G$, è possibile instradarlo in $G^{sc}$ usando la \textbf{flow decomposition} per ottenere da $f$ un insieme di path diversi almeno per un arco,
    \[f := \{P^0, P^1, ..., P^k\}\]
    Possiamo suddividere ancora ogni $P^a\in f$ in subpath \[P^{a}_{i\rightarrow j}| i\in N^{sc}\land j\in N^{sc}\land \forall q \in P^a_{i\rightarrow j}, q\not = i \land q\not = j \implies q\in N\setminus N^{sc}\] 
    A questo punto sostituiamo ogni $P^{a}_{i\rightarrow j}$ in $G$ non  interamente contenuto in $G^{sc}$ con lo pseudo arco corrispettivo $(i,j)$.
    \QED
\end{proof}



\section{Da sc-compact a $\Gamma$-compact}
Il grafo sc-compact non è abbastanza compattato per raggiungere il costo desiderato. Per compattarlo ulteriormente dovremmo utilizzare un parametro \gmm per scegliere quali nodi compattare e da quali archi trasferire capacità residua.
La scelta del parametro \gmm\ verrà mostrata in seguito.
Prima di proseguire è importante distinguere diversi tipo di archi.
\begin{definition}{Classificazioni di capacità}{}
    Un arco $(i,j)$ rispetto a $\Gamma$ ha:
    \begin{enumerate}
        \item \textbf{small capacity} se $u_{ij}+u_{ji} < \Gamma/(64m^3)$
        \item \label{media}\textbf{medium capacity} se $\Gamma/(64m^3) \le u_{ij}+u_{ji}\ \land$\\ $r_{ij} < 2\Delta \land r_{ji} < 2\Delta $
        \item \textbf{abundant capacity} se $r_{ij} \ge 2\Delta$ 
        \item \textbf{antiabundant capacity} se $(j,i) \in E^{ab} \lor\ (i,j)$ è un arco esterno non abbondante.
    \end{enumerate}
    Dove $E^{ab}$ e $E^{-ab}$ rappresentano rispettivamente l'insieme degli archi abbondanti e anti abbondanti all'inizio dell'improvment phase.

    \underline{NOTA}: dato che abbiamo contratto i cicli abbondanti se $(i,j)\in E^{ab}\implies (j,i)\not \in E^{ab}$
    
\end{definition}

Un altro strumento necessario per decidere quali nodi compattare è la funzione \textit{potenziale}
\begin{definition}{Potential function}{}
    Dato un nodo $j\in N$ una funzione di capacità residua $r$ e un sottoinsieme di archi adiacenti a $j$ $\tilde{E}$  possiamo definire la funzione potenziale come: 
    \[\Phi (j, r, \tilde{E}) = \sum_{(i,j)\in \tilde{E}} r_{ij}-\sum_{(j,i)\in \tilde{E}} r_{ji}\] 
\end{definition}

    \begin{definition}{$\Gamma$-critical e $\Gamma$-compactible}{}
        
        Un nodo j si dice \textbf{$\Gamma$-critical} se è adiacente almeno ad un arco \gmm-medio oppure se $|\Phi (j, r, E^{-ab})| > \Gamma/(16m^2)$.

        \vspace*{7pt}
        \noindent Se un nodo non è $\Gamma$-critical allora si dice \textbf{$\Gamma$-compactible}.

        \vspace*{7pt}
        \noindent Dato un network $G$ definiamo il \gmm\-compact network di $G$ come \[G^c := (N^c, E^c)\]
        Dove $N^c$ sono tutti e soli i nodi \gmm-critical mentre $E^c$ l'insieme di archi che definiremo in seguito.
    \end{definition}
    Per costruire il $\Delta$-compact network vengono iterativamente trasferite unità di capacità residue di vari path a pseudo archi. 
    l'idea è quella di sottrarre capacità a dei percorsi che collegano due nodi $i,j\in N$ per passarla all'arco (o pseudo arco) $(i,j)$ e poter ulteriormente compattare il grafo.
    Ovviamente però questi pseudo archi sono solo parte di quelli che compongono $E^c$ che potremmo definire come 
    \[E^c = E^1\cup E^2 \cup E^3\]
    $E^1 = \{(i,j) | i,j\in N^c \land (i,j) \in E(G)\}$ dunque gli archi originali che collegano due nodi \gmm-critici\\
    $E^2 = \{(i,j) | i,j\in N^c \land i\implies j\}$ ovvero gli archi abbondanti 

    Il seguente lemma mostra come se scelti secondo un appropriato criterio, il trasferimento di flusso non riduce la capacità di nessun (S,T) cut e dunque preserva il max flow calcolabile.
    \begin{lemma}[label = {ftsafe}]{Flow transfer safety}{}
        Sia $(S,T)$ un s-t cut in $G$ con $r(S,T)\le \Delta$, e sia $A' = E^{-ab}.$\\
        Supponiamo che esista $P\subseteq A'$ un path da $i\rightarrow j$ e che $(i,j)\in A'$. \\
        Se $r'$ è la nuova funzione di capacità residua ottenuta spostando $\delta$ unità di capacità residua da $P$ a $(i,j)$, allora possiamo affermare che:
        \begin{enumerate}
            \item $\forall k\in N(G),\ \Phi(k,r',A') = \Phi(k,r,A') $
            \item $r'(S,T) = r(S,T)$
        \end{enumerate}
        
    \end{lemma}
        \begin{proof} \begin{enumerate}
                \item Il primo punto è intuitivo in quanto per ogni nodo in $P$ diverso da $i$ e $j$ sto sottraendo la stessa capacità residua sia in entrata che in uscita, mentre nei nodi $i$ e $j$ le sommatorie di $\Phi$ rimangono identiche.
                \item Il secondo punto è banale se $|P|= 1$ dunque consideriamo $|P|\ge 2$. Definiamo $P = p_1, ..., p_k$, $p_1 \in S$ e almeno un $p_q\in T$.\\
                    Dato che abbiamo stabilito che $r(S,T) \le \Delta$ e che $P\subseteq A'$ ci troviamo sicuramente in una situazione di questo tipo:
                    \[\begin{tikzpicture}[node distance={15mm}, thick , main/.style = {draw, circle}] 
                        % Disegna i nodi del grafo
                        \node[main] (0) {$i$};
                        \node[main] (1) [above right of = 0] {1};
                        \node[main] (2) [right of = 1] {2};
                        \node[main] (3) [below right of = 2] {j};
                        \node at (0,1.7) {S};
                        \node at (3.6,1.7) {T};
    
                        \draw[->] (0) [red, bend left] to (1);
                        \draw[->] (1) [red, bend left] to (2);
                        \draw[->] (2) [red, bend left] to (3);
                        \draw[->] (0) [green, bend right] to (3);
    
                        \draw[dashed] (1.8,-1) -- (1.8,1.7);
                    \end{tikzpicture}\]
                    In quanto se un arco di $P$ passasse da T a S violerebbe $r(S,T)\le \Delta$ dato che $\forall (a,b)\in A'(\Delta),\ r_{ab} > 2\Delta \land r_{ba}\ge 2\Delta$, avremmo che
                    \[\begin{tikzpicture}[node distance={15mm}, thick , main/.style = {draw, circle}] 
                        % Disegna i nodi del grafo
                        \node[main] (0) {$i$};
                        \node[main] (1) [above right of = 0] {1};
                        \node[main] (2) at (3.8,0) {2};
                        \node[main] (3) [below right of = 0] {j};
                        \node at (0,1.7) {S};
                        \node at (3.6,1.7) {T};
    
                        \draw[->] (0) [red,bend left] to (1);
                        \draw[->] (1) [red,bend left] to (2);
                        \draw[->] (2) [red,bend left] to (3);
                        \draw[->] (3) [thick = 1.5, darktangerine, bend left] to (2);
                        \draw[->] (0) [green, bend right] to (3);
    
                        \draw[dashed] (1.8,-1.7) -- (1.8,1.7);
                        \node at (2.4, -.4) {\text{\color{darktangerine}{$2\Delta$}}};
                    \end{tikzpicture}\]
                Una volta appurato ciò risulta evidente che il trasferimento di capacità residua non influenza la capacità residua del taglio. \QED
            \end{enumerate}
        \end{proof}
    Notiamo dunque che:
    \begin{definition}
        {Transferrable residual capacity}{}
        Per poter trasferire $\delta$ capacità da un path $P$ da $i\rightarrow j$ all'arco $(i,j)$ è necessario che:
        \begin{enumerate}
            \item $|P|\ge 2$
            \item $r(P) > 0$
            \item $P\subseteq A'$
       
        In oltre quando creeremo il \gmm\ compact network saranno essenziali anche i seguenti requisiti
        \item $i,j \in N^c$
        \item $P\setminus \{i,j\} \subseteq N(G) \setminus N^c$
    \end{enumerate}
    \end{definition} 
    La capacità che viene trasferita da è $\delta = r(P) = \min_{(a,b)\in P} r(a,b)$, dunque ogni volta almeno un arco anti-abbondante viene saturato. 
    Se esiste un path $P\subseteq A'\ da\ i\rightarrow j $ ma $(i,j)\not \in E(G)$ allora viene creato come pseudo arco. 
    Sono proprio questi Pseudo archi antiabbondanti che formeranno $E^3$. 
    Analizziamo ora la procedura per trasferire tutte le capacità residue necessarie a formare $E^3$ e restituirne l'insieme di archi
    con le relative capacità residue $r^c_{ij} \forall (i,j)\in E^3$

\begin{algo}[label = algotrans]{Procedura: trasferimenti di capacità $(r, \Gamma)$}{}
    \begin{enumerate}
        \item sia $G^c := \{n | n\in N(G)\land \Gamma\text{-critical}(n)\}$
        \item sia $H := \{(i,j)| (i,j)\in E^{-ab}\land i \not \in G^c \lor j \not \in G^c\}$
        \item $\forall (i,j)\in H,\ q_{ij} = r_{ij}$
        \item while H $\not = \varnothing$:
        \item seleziona $i \in H | \nexists (j,i) \in H$:
        \item P = $DFS(i, l)$ s.t $l\in N^c \lor \nexists (l,k)\in H$ \# usa la DFS per trovare un path da $i$ a $l$ 
        \item sia $\delta = \min_{(a,b)\in P}q_{ab}$
        \item if $i,l \in N^c$ then $A^3 = A^3 \cup {(i,l)}; r^c_{i,l} += \delta$
        \item $\forall (a,b) \in P,\ q_{ab} -= \delta$
        \item $H = H- \{(a,b) | q_{ab} = 0\}$ 
    \end{enumerate}
\end{algo}
Nel passaggio 6 viene creato, utilizzando una \textit{deep first search} un percorso dal nodo scelto $i$ fino ad uno $l$ che soddisfi certi requisiti.
Da notare con attenzione che \textbf{non è garantito} che $i$ e $l$ siano \gmm-critical e dunque è possibile che tale percorso (che esiste sempre) venga scartato.

Quando un percorso viene scartato si dice che $\delta$ capacità è stata \textbf{persa}. 
Dunque il max flow nel grafo \gmm-compact è inferiore a quello ottimale, tuttavia il seguente lemma mostra che esiste un bound a questa capacità residua \textit{persa}.
\begin{lemma}[label = boundlose]{bound to \gmm-compact lose capacity}{}
    Sia $f_{max}$ il max-flow calcolato in $G$, il network originale, e $f^*$ quello calcolato in $G^c$, il network compattato creato dalla \nameref{algotrans}.
    Allora si ha che:
    \[f^*\le f_{max} \le f^* + \Gamma/16m\]
    ovvero il flusso massimo calcolato in $G^c$ è sottostimato di al più $\Gamma/16m$.
\end{lemma}
\begin{proof}
    Per essere scartato, un percorso deve iniziare o terminare in un nodo \gmm-compactible ovvero un nodo $j$ non adiacente ad un arco medio tale che:
    \[|\Phi (j, r, E^{-ab})| =\left | \sum_{(i,j)\in E^{-ab}} r_{ij}-\sum_{(j,i)\in E^{-ab}} r_{ji}\right |\le \Gamma/16m^2\]
    Tuttavia un nodo non critical per essere scelto deve avere solo archi entranti o solo archi uscenti a seconda di quale estremo del path stiamo parlando.
    Possiamo quindi stimare che la capacità massima di un certo path $P_s$ scartato sia $r(P_s) \le  \Gamma/16m^2$ ovvero il valore residuo massimo raggiungibile da un arco estremo a $P_s$.
    Dato quindi che possono esistere al massimo $n$ di questi percorsi allora abbiamo che: 
    \[n\cdot \Gamma/16m^2 \le m \cdot \Gamma/16m^2 = \Gamma/16m\]
    Dunque la massima capacità che viene persa nella creazione di $G^c$ è proprio $\Gamma/16m$ \QED.
\end{proof}

Dobbiamo ora assicurarci che un flow calcolato in $G^c$ che chiameremo $\alpha$-ottimale, sia trasferibile nel Network originale $G$.

Sia $f'$ il flow calcolato in $G^c$ e rappresentiamo con $f$ la trasposizione di $f'$ in $G$:\\
Se $f'_{i,j}> 0\land (i,j) \in E(G)\implies f_{i,j} = f'_{i,j}$ basta riportarlo così com'è.
se $f'_{i,j}> 0\land i \Rightarrow j \implies$ si tratta del compattamento di un path abbondante e per ripristinare il flusso basta usare la matrice di transitività.
Il caso più interessante rimane quello che si verifica quando dobbiamo trasporre il flusso da uno pseudo-arco di archi abbondanti ai path che lo hanno generato.
Infatti è importante ricordare che lo la capacità dello pseudo-arco è la somma delle capacità residue dei path che sono strati trasferiti in precedenza.
Tenere traccia di tutti i path trasferiti risulterebbe troppo inefficiente, tuttavia utilizzando gli alberi dinamici possiamo potenziare l'algoritmo precedentemente utilizzato per fare in modo di mantenere un record con tutte le operazioni effettuate sull'albero.
In questo modo è possibile, consultando il record a ritroso, ricostruire in tempo $k\log n$ (dove $k$ è  il numero di operazioni sul link-cut tree) le capacità trasferite dalla procedura in maniera sequenziale, potendo così adattare la giusta porzione di flusso in ogni arco.

Studiamo ora l'adattamento dal punto di vista dell'$(S,T)$-$cut$:\\
Sia $(S',T')$ un cut in $G[r]$ e supponiamo che non esistano archi abbondanti da $S$ a $T$,
un taglio $(S^c,T^c)$ in $G^c$ di dice \textbf{indotto da}  $(S',T')$ se: \[(S^c, T^c) := (S'\cap N(G^c), T'\cap N(G^c))\]
Viceversa un taglio in $G^c$ si dice indotto da uno in $G[r]$ se composto come segue:
\[\begin{array}{l}
    S':=\{n | n\in S^c\lor \exists m \in S^c,\ m \implies n\}\\
    T' = N(G)\setminus S'
\end{array}\]

\begin{obs}{}{}
    Osserviamo che se un $(S',T')$ è indotto da  $(S^c,T^c)$ allora  $(S^c,T^c)$ è indotto da $(S',T')$.
        \[(S',T')\leftarrow(S^c,T^c)\implies (S^c,T^c)\leftarrow(S',T')\]

    Non è vero il contrario in quanto diversi cut su $G[r]$ possono indurre lo stesso $(S^c,T^c)$.
\end{obs}

\begin{lemma}{}{}
    Supponiamo che $(S',T')$ sia un cut in $G[r]$ e che non esistano archi abbondanti da $S$ a $T$.
    Se $(S^c,T^c)$ è indotto da $(S',T')$ allora \[ r(S^c,T^c) \le r(S',T')\le r(S^c,T^c)+\Gamma/16m\]
\end{lemma}
\begin{proof}
    Sappiamo che gli archi originali in $E^1$ contribuiscono in egual misura sia in $(S^c,T^c)$ che in $(S',T')$, quelli abbondanti non sono presenti per ipotesi e dunque rimangono solo quelli in $E^3$.
    dividiamo path calcolati dalla \nameref{algotrans} come $P\cup Q$ dove $Q$ sono quelli che alla fine vengono scartati.
    Dal lemma \ref{ftsafe} sappiamo che trasferire la capacità non influenza la capacità del taglio. Quindi gli unici archi che possono influenzare la capacità residua restano quelli in $Q$.
    Ma sappiamo dal lemma \ref{boundlose} che:
    \[\sum_{p\in Q}r(p)\le \Gamma/16m\]\QED
\end{proof}


Dai precedenti lemmi possiamo quindi giungere all'asserzione del seguente teorema
\begin{theo}{}{}
    Sia $y$ un $\alpha$-optimal flow nel \gmm-compact network $G^c$.
    Sia $(S^c,T^c)$ un taglio in $G^c$ tale che \[r(S^c,T^c)\le val(y)+\alpha\] 
    Se $(S',T')$ è il taglio indotto da $(S^c,T^c)$ in $G[r]$ e $y'$ il rispettivo flow allora
    \[val(y') = val(y)\]
    e $y'$ si dice $\alpha'$-ottimale dove $\alpha' = \alpha + \Gamma/16m$.\\
    Dunque $r(S',T') \le v+\alpha'$
\end{theo}

\section{Max flow in $O(nm)$ time}

Mostreremo in questa sezione come è possibile calcolare il max flow in tempo $O(nm)$ quando $m = O(n^{1.06})$.
Mostreremo anche che il bottleneck di questa procedura è dovuto al mantenimento della chiusura transitiva di $G^{ab}$.


\begin{algorithm}
\caption{\textit{Improve-approx-2(r,S,T)}}
\label{imp2}
\begin{algorithmic}[1]
\State $\Delta := r(S,T)$
\State $c = |N^c|$
\If{$c \ge m^{9/16}$}
    \State $\Gamma = \Delta$
    \State find a $\Gamma/(8m)$-optimal flow in $G[r]$
\ElsIf{$m^{1/3}\le c \le m^{9/16}$}
    \State $\Gamma = \Delta$
    \State $G^c:= \Gamma$-compact network
    \State $y=\Gamma/(8m)$-optimal flow in $G^c$
    \State $y' = induced(y, G[r])$
    \State $update(r)$
\ElsIf{$c<m^{1/3}$}
    $\Gamma = choseGamma(c, \Delta)$
    \State $G^c:= \Gamma$-compact network
    \State $y=$ optimal flow in $G^c$
    \State $y' = induced(y, G[r])$
    \State $update(r)$
\EndIf
\end{algorithmic}
\end{algorithm}
Una delle prime cose che possiamo capire osservando questo algoritmo è la complessità richiesta per la creazione del network \gmm-compact che enunciamo nel seguente teorema.
\begin{theo}[label = tgcomp]{Costrutire un compact network}{}
    Supponiamo che l'algoritmo mantenga dinamicamente la chiusura transitiva del grafo di abbondanza e 
    che il parametro \gmm\ sia fornito in partenza, allora
    l'algoritmo impiega tempo $O(m^{9/8})$ a creare il grafo compatto $G^c$.
\end{theo}
\begin{proof}
    Per contrarre i componenti abbondanti connessi, così come i cicli, è necessario tempo $O(m)$.
    Per quanto riguarda il grafo compattato: 
    \begin{itemize}
        \item Gli archi in $A^1$ possono essere calcolati in $O(m)$; 
        \item Gli archi in $A^3$ possono essere calcolati in $O(m\log m)$ utilizzando gli alberi dinamici;
        \item Quelli che sono più complessi da calcolare sono gli archi abbondanti di $A^2$ che vengono calcolati basandosi sulla chiusura transitiva che richiede costo ${|N^c|}^2$ per essere mantenuta.
    \end{itemize}
    Tuttavia l'algoritmo costruisce $G^c$ solo se il numero di nodi \gmm-critici è minore di $m^{9/16}$ dunque il costo diventa
    \[O((m^{9/16})^2) = O(m^{9/8})\]
\end{proof}

Di seguito se vogliamo dimostrare che la complessità di tutto l'algoritmo è proprio quella dichiarata in partenza abbiamo bisogno di porre dei bound tanto alle azioni che vengono compiute quanto agli oggetti che vengono analizzati.
La prima cosa da dichiarare è che il numero di tutti i nodi \gmm-critici analizzati durante le varie fasi è in $O(m)$
\begin{theo}[label = maxM]{max critical node in $O(m)$}{}
    Supponiamo che ogni improvement phase soddisfi i requisiti richiesti allora  i nodi \gmm-critici calcolati durante le iterazioni sono in tutto $O(m)$
\end{theo}
\begin{proof}
    per essere \gmm-critico un nodo $j$ deve essere adiacente ad un arco \gmm medio oppure non avere archi adiacenti \gmm medi ma avere $|\Phi (j, r, E^{-ab})| > \Gamma/(16m^2)$ ovvero essere \gmm-special.

    Consideriamo prima i nodi adiacenti ad un arco \gmm-medio:\\
    \textbf{Claim:}\\
    Un arco può avere capacità \gmm-media per al massimo 3 fasi consecutive.

    \textit{proof:}\\
    Sia (i,j) un arco di \gmm-media capacità allora $u_{ij} + u_{ji} \ge \Gamma/64m^3$ dato che ad ogni fase $\Delta' = \frac{\Delta}{8m}$
    allora nella fase subito successiva  \[u_{ij} + u_{ji} \ge \Gamma/64m^3 \ge \Delta'/8m^2 =\Delta''/m = 8\Delta''' \]
    Ottenendo dunque che dopo 3 fasi $u_ij+u_ji \ge 8\Delta$ dunque o $(i,j)$ o $(j,i)$ sono diventati abbondanti e l'arco non è più \gmm-medio.

    Per quanto riguarda gli altri archi \gmm-special invece:\\
    \textbf{Claim:}
    Sia \gmm il parametro di compattezza di una certa \dlt-improvement phase e sia $j$ un nodo \gmm-special.
    Se $\Delta^*$ è il bound 4 fasi dopo \dlt allora esiste un nodo $k$ tale che 
    \[r_{jk}\ge 2\Delta^*\land r_{kj}\ge 2\Delta^* \] 
    ovvero $(j,k)$(ma anche $(k,j)$) è \textit{doubly-abundant}, e dunque verrà contratto.
    \textit{proof:}\\
    Per prima cosa definiamo $v^*$ il flusso nella fase $\Delta^*$ tale che $r^* = r_{ij}-v_{ij}+v_{ji}$.
    Dal lemma \ref{ab4ever} sappiamo che ogni arco \dlt-abbondante sarà anche $\Delta^*$-abbondante e in oltre
    \[r_{ij}^* > \Gamma/64m^3 \implies r_{ij}^*> 8\Delta^*\]

    Supponiamo che esista un arco abbondante $(j,k)$ con valore di $v_{jk}^*>\Gamma/64m^3$ allora per l'arco opposto $(k,j)$ vale
    \[r^*_{k,j}= r_{kj}-v^*_{kj}+r^*_{jk}> 8\Delta^*\]
    Dunque anche l'opposto è $\Delta^*$-abbondante e i nodi $j$ e $k$ vengono contratti.

    Rimane dunque da verificare il caso in cui un nodo $j$ sia \gmm-special senza avere archi $\Delta$-abbondanti con flow maggiore di $\Gamma/64m^3$.\\
    Sappiamo che:
    \[|\Phi (j, r, E^{-ab})| = |\hat{r}_{out}(j)-\hat{r_{in}}(j)|> \Gamma/(16m^2) \]
    consideriamo il caso in cui $\hat{r}_{out}(j)-\hat{r_{in}}(j)> \Gamma/(16m^2)$(l'altro è speculare)
    Abbiamo che:
    \[\sum_{j:(j,k)\in E^{-ab}}y^*_{jk} \le \sum_{j:(j,k)\in E}y^*_{jk} = \sum_{j:(i,j)\in E}y^*_{ij}\]
    per conservazione del flusso, in oltre 
    \[\sum_{j:(i,j)\in E}y^*_{ij} < \sum_{j:(i,j)\in E^{-ab}}y^*_{ij} + \sum_{j:(i,j)\in E^{ab}}y^*_{ij}+ m\Gamma/64m^3\]
    ma dato che abbiamo assunto che nessun arco abbondante ha flow maggiore di $\Gamma/64m^3$
    \[\begin{array}{rl}
        < & \hat{r}_{in}(j) + 2m\Gamma/64m^3\\
        < & (\hat{r}_{out}(j) - \Gamma/16m^2) + \Gamma/32m^2\\
        < & \hat{r}_{out}(j) - \Gamma/32m^2\\
        = & \sum_{j:(j,k)\in E^{-ab}}r_{jk} - \Gamma/32m^2
    \end{array}\]

    Deve esistere dunque qualche arco per cui 
    \[y^*_{jk}<r_{jk}-\Gamma/32m^3\implies r^*_{jk}\ge r_{jk}-y^*_{jk}>\Gamma/32m^3>16\Delta^*\]
    Dunque esiste qualche $(j,k)$ arco antiabbondante nella fase \dlt che diventa abbondante nella 
    fase $\Delta^*$ e dunque, dato che anche $(k,j)$ è abbondante il ciclo viene contratto.\QED
\end{proof}

Conoscendo il numero di nodi da analizzare il passo successivo sarebbe stimare il numero di \textbf{improvement phase} per calcolare il max flow. 
Prima però è necessario comprendere il modo in cui viene scelto il parametro \gmm.

\begin{lemma}[label = gammchose]{Il parametro \gmm}{}
    Il parametro \gmm\ può essere scelto in tempo $O(m+n\log n)$
\end{lemma}
\begin{proof}
    \begin{enumerate}
        \item Per ogni nodo $j$ calcoliamo il più grande valore \gmm'\ per cui j è \gmm'-critical (\textit{tempo richiesto} $O(m)$)
        \item Ordiniamo i nodi $j$ per il loro valore \gmm' (\textit{tempo richiesto }$O(n\log n)$)
        \item scegliamo il valore \gmm\ tale che esistano al massimo $m^{1/3}$ nodi j con $\Gamma'(j)\ge \Gamma$ (\textit{tempo richiesto }$O(1)$)\\\QED
    \end{enumerate}

\end{proof}

Abbiamo ora tutti gli strumenti per calcolare il numero di improvement phase:
\begin{lemma}{}{}
    Il numero di improvement phase in $O(m^{2/3})$
\end{lemma}\begin{proof}
    Sappiamo dal teorema \ref{maxM} che il numero di nodi \gmm-critici analizzati è $O(m)$ e sappiamo dal lemma \ref{gammchose} che in ogni improvement phase almeno $m^{1/3}$ vengono analizzati.
    
    Quando abbiamo dimostrato che il numero di nodi era $O(m)$ la dimostrazione verteva sul fatto che i nodi avessero una "scadenza" e che in massimo 3 o 4 fasi consecutive sarebbero stati contratti.
    Quindi tutti gli almeno $m^{1/3}$ nodi analizzati in una fase verranno consumati in $O(1)$ fasi.
    Di conseguenza il numero di fasi necessarie per "consumarli" tutti è proprio $O(m^{2/3})$.\QED
\end{proof}

Dai seguenti lemmi possiamo giungere dunque al tempo totale richiesto per creare tutti i $G^c$.
\begin{lemma}{}{}
    Il tempo totale per creare tutti i compact network è $O(nm+m^{43/24})$
\end{lemma} 
\begin{proof}
    Sappiamo che il parametro \gmm\ richiede tempo $O(m+n\log n)$\\
    Sappiamo che per creare un compact network serve tempo $O(m^{9/8})$.\\
    Dato che il numero di fasi sono $m^{2/3}$,\\
    mettendo tutto insieme otteniamo:
    \[O(mn+m^{43/24} )\]
    \QED
\end{proof}

Trovare un flusso che che sia $\alpha$-ottimale significa trovare un flusso che sia inferiore a quello di capacità massima di al più $\alpha$.
abbiamo visto che se cerchiamo il flusso massimo sul \gmm-compact network $G^c$ e poi lo trasponiamo sul network originale $G$ questo è già $\Gamma/16m$-ottimale. 

Tuttavia durante l'algoritmo noi cerchiamo di ottenere questa approssimazione direttamente in $G$. 
Se ricordiamo però il funzionamento del Goldberg-Rao possiamo vedere che l'algoritmo termina quando la stima che fa del flusso massimo è minore di 1.
Intervenendo su questa stima del flusso massimo è possibile far terminare l'algoritmo prima che si arrivi al flusso ottimale ottenendo un distacco di massimo un valore $\alpha$ a nostra scelta.

Ragioniamo ora sul costo $T$ di una fase del Goldberg-Rao sapendo di eseguirlo su un grafo con $C$ nodi e $O(C^2)$ archi.
\[ \Lambda = O(C^{2/3}),\quad T = \tilde O(C^{2/3}\cdot C^2) =\tilde O(C^{8/3})\]
Possiamo ora valutare il costo della procedura \hyperref[imp2]{Improve-approx-2} 

In oltre possiamo notare che se eseguiamo il Goldberg rao su un totale di O(m) nodi eseguendo un massimo di $\log U$ fasi il numero medio di nodi in ogni improvement phase è
\[C = O\left (\frac{m}{\log{U}}\right )\]
da qui il motivo per cui nella procedura costruiamo il grafo compatto solo se $C \le m^{9/16}$ infatti se il Goldberg è polinomiale se $\log U \le m^{7/16}$ allora 
\[C\ge m^9/16 \implies \frac{m}{\log U}\ge m^{9/16} \implies \log U \le \frac{m}{m^{9/16}} = m^{7/3}\]

\begin{lemma}{Time of improve-max}{}
    Il tempo per calcolare il flusso ottimale utilizzando sempre la procedura improve-approx 2 è 
    \[O(m^{31/16}\log^2m)\]
\end{lemma}
\begin{proof}
Dato che in tutto vengono calcolati $O(m)$ nodi \gmm-critici, calcolo il costo della procedura sul singolo nodo invece che per il numero di fasi:
Sia T il tempo necessario per trovare un $\alpha$-optimal flow\\
Sappiamo che se $C \ge m^{9/16}$ possiamo trovare un optimal flow con $T = O(m^{3/2}\log^2 n)$ eseguendo $\log n$ fasi del goldberg rao sul grafo originale. Rapportato al numero di nodi \gmm-critici otteniamo che $T/C = m^{15/16}\log^2n$. 
se invece $ m^{1/3} \le C < m^{9/16}$ lavoriamo nel grafo compattato e cerchiamo il max flow eseguendo $\log n$ fasi del goldberg avendo $T = O(C^{8/3} \log n)$ dunque \[T/C = O(m^{5/3}\log n = m^{15/16})\]
In fine se $C < m^{1/3}$ otteniamo che l'esiguo numero di archi porta il costo ad essere $ T= O(C^3)$ di conseguenza $T/C = O(C^2) = O(m^{2/3})$.

Possiamo affermare che in ogni caso il costo del della procedura per ogni nodo è $O(m^{15/16}\log^2n)$. Moltiplicando il risultato per il numero di nodi \gmm-critici su tutti gli incrementi otteniamo \[O(m\cdot m^{15/16}\log^2n) = O(m^{31/16}\log^2n)\] 
\QED
\end{proof}

\begin{lemma}{}{}
    Il tempo totale per trasformare tutti i flussi calcolati su $G^c$ in flussi sul grafo residuo è 
    \[O(nm+ m^{5/3}\log n)\]

\end{lemma}
\begin{proof}
    Sia $G^c$ il grafo compatto determinato da $G[r]$ il grafo residuo e sia $y^c$ il flusso in  $G^c$ mentre $y$ è quello indotto sul grafo residuo.

    Gli archi di $G^c$ sono divisi in tre categorie $E^c = E^1\cup E^2\cup E^3$ rispettivamente gli archi originali, gli pseudoarchi abbondanti e gli pseudoarchi antiabbondanti.

    preso un qualsiasi arco $(i,j)$ tale che $y^c_{ij}> 0$ distinguiamo i tre casi:
    \begin{enumerate}
        \item se $(i,j) \in E^1 \implies y_{ij} = y^c_{ij}$
        \item se $(i,j) \in E^2$ sappiamo che per ricostruire l'abundant path abbiamo bisogno di $O(|P|) = O(n)$, in oltre sfruttando gli alberi dinamici possiamo tenere il numero di archi con flow positivo in $E^2$ sotto il valore $C$ al costo $O(m\log n)$, che ripetuto per $O(m^{2/3})$ fasi fa $O(m^{5/3}\log n)$. In questo modo, tutti gli abundant path vengono ripristinati in $O(nm)$.
        Per ricotruire gli abundant path ricordiamo sempre che il costo di mantenere dinamicamente la chiusura transitiva è di $O(nm)$
        \item Per quanto riguarda gli archi in $E^3$ ancora una volta dobbiamo ricorrere agli alberi dinamici per ricostruire i percorsi anti abundant che abbiamo contratto. In particolare non è possibile tenere traccia di tutti i percorsi in maniera efficiente, tuttavia possiamo tenere un record con tutte le operazioni fatte sul grafo per poterle ripercorrere a ritroso e restaurare i vecchi path. Anche questa procedura ha costo complessivo di $O(m\log n\cdot m^{2/3})$ 
    \end{enumerate}
    Concludiamo che il tempo totale per indurre il flow su $G^c$ in $G[r]$ per tutte le $m^{2/3}$ fasi è 
    \[O(nm+m^{5/3\log n})\]\QED
\end{proof}

Dai precedenti Lemmi possiamo dedurre il seguente teorema
\begin{theo}{max flow in $O(nm)$}{}
    Se il flow in ogni improvement phase è calcolato utilizzando la procedura \textit{improve-approx-2} allora il tempo per trovare il flow di valore massimo è 
    \[O(nm+M^{31/16}\log^2n)\]
    se $m= 1^{1.06}$ il running time è
    \[O(nm)\]
\end{theo}


\chapter*{Bibliografia}
    Le fonti sull'algoritmo di Goldberg-Rao e su quello di Orlin vengono dai seguenti articoli:
   \begin{enumerate}
    \item  Max flows in O(nm) time, or better, Revised: July 25, 2012, James B. Orlin*
    \item The Goldberg-Rao Algorithm for the Maximum Flow Problem, October 18 2006, Dávid Papp
   \end{enumerate}


\end{document}