
\chapter{Goldberg-Rao Algorithm}

\label{chap:gbr}
After understanding how Dinic's algorithm works, we can move to the next step and focus on the algorithm published by Andrew V. Goldberg and Satish Rao in 1998.

\noindent By optimizing the \nameref{chap:dnc}, the Goldberg-Rao algorithm achieves a \textbf{computational cost} of 
\[
\tilde{O}(\min\{n^{2/3}, m^{1/2}\} \cdot m)
\]
on a network with integer capacities, which, when considering logarithmic factors, becomes \( O(\min\{n^{2/3}, m^{1/2}\} m \log n \log nU) \).

\textbf{Note:} From here on, we will abbreviate the expression \( \min\{n^{2/3}, m^{1/2}\} \) using \( \Lambda \).

\section{Idea}

    At the core of the optimization is the idea of \textbf{contracting} the network according to certain specific parameters.  
    The speed-up lies in computing the flow in a contracted graph, which is more efficient than computing it in the original one.
    The algorithm is based on \nameref{VDL} and introduces a new  \textbf{\underline{binary} length function} : \( \bar{l}((v,w)): E \rightarrow \{0,1\} \).  

    The new length function assigns a value of zero to all edges that meet certain capacity requirements (which we will describe in more detail later), such edges are called "zero length".

    By setting the length of the edges connecting two or more nodes to zero, we can consider them as a single node.  
    Thus, by contracting the components connected by edges of length 0, it is possible to significantly reduce the number of flow increments and therefore the computational cost of the algorithm.

\section{The $\Delta$ parameter}

    The issue with contracting the graph is that when we send flow from the source to the sink, we must ensure that this flow respects the capacity constraints of all the edges, including those that were contracted.  
    To ensure that the flow calculated on the contracted graph is valid for the original graph as well, a parameter \dlt\ is used, which serves two purposes. The first function is as a \textbf{lower bound} on the capacity of zero-length edges.  
    In fact, edges with residual capacity greater than \dlt\ are first selected, and the length of these edges is set to 0.  
    Subsequently, all components connected by zero-length edges are contracted.  
    Finally, a blocking flow (exactly as in Dinic's algorithm) is calculated in the contracted graph.  
    At this stage, the parameter \dlt\ serves its second function, which is as an \textbf{upper bound for the blocking flow}. In fact, the computation of the blocking flow stops either when such a flow is found, or just before the flow value exceeds \dlt. This second condition ensures that the flow remains feasible even for the original network.

    By increasing the flow by at most \dlt, we ensure that the capacity constraints are respected, but we can no longer guarantee that the flow is blocking.  
    Therefore, we must choose a value for \dlt\ that is both small enough to contract the graph as much as possible, but also adequately selected to keep the number of flow increments as low as possible, thus ensuring the desired computational cost.

\section{Stop condition}
    To terminate its execution, the algorithm estimates the difference between the maximum achievable flow (which from now on will be called $F$) and the flow it has computed.
    When this difference becomes less than 1, the algorithm terminates.
    Since the capacities of the network are all integers, this ensures that the maximum possible flow has been reached.
    An initial useful value for $F$ is $F=n\cdot U_{max}$, and later, the residual capacity of the canonical cut will be used (further details will be provided later).


\section{Stimare il residual flow}
    We already know that the residual capacity of each cut $r(S,T)$ represents an upper bound on the max flow (\nameref{maxFlowMinCut}).
    To estimate the residual flow quickly and efficiently, we can analyze the \nameref{cancut}.

    \begin{lemma}{min $r(S_k,T_k)$ in $O(m)$ time}{}
        The canonical cut with the minimum capacity can be found in $O(m)$ time.
    \end{lemma}
    \begin{proof}

        Exploiting the fact that each edge has a length of at most 1, and therefore can cross at most one canonical cut, we can define the following subroutine.
        \begin{algorithm}[H]
            \caption{\textit{canCutCapacity($G_f$, d, l)}}
            \label{canCutCapacity}
            \begin{algorithmic}[1]
                \For{$k\leftarrow 0\ to\ d(s)$}  $r(S_k,T_k) = 0$
                \EndFor
                \For{$(u,v)\in E(G_f)$}  \If{$d(v) > d(w)$} $r(S_{d(v)},T_{d(v)}) += r(v,w)$\EndIf
                \EndFor
                \State\Return  $\text{argmin}\ r(S_k,T_k)$
            \end{algorithmic}
        \end{algorithm}
    The correctness and computational cost of this routine are fairly straightforward.
    \end{proof}

    To manage the computational cost, we need to ensure that the value of $F$ decreases quickly enough without overburdening the algorithm.  
    First, we can group all the iterations of the algorithm into \textbf{phases} and update the value of $F$ at the minimum canonical cut only between the end of one phase and the start of a new one. If we update the value of $F$ only when $\min r(S_k, T_k) \leq F/2$, the algorithm will terminate after at most $\log nU_{max}$ phases.

\section{Binary length function}
    There are two other issues that arise from contracting the graph and modifying the length function:
    \begin{enumerate}
        \item Choosing a \dlt\ that is too small would make the flow increase too slowly, while choosing it too large would not contract the graph enough to justify the management costs.
        \item In Dinic's algorithm, the blocking flow always guaranteed an increase in the distance from $s$ to $t$, but with zero-length edges, this is no longer guaranteed.

    \end{enumerate}
    In this section, we show the choices that were made to address these two issues. While the effectiveness of the solution to the second problem is promptly demonstrated, the effectiveness of the choice of the \dlt\  parameter will only become clear in the section where the various computational costs are proven.
    \subsection{How to zero lengths}
    As previously mentioned, we need an upper bound \dlt\  to respect the capacity constraints. At the same time, to meet the declared computational cost, we need the blocking flow increments to be at most $\Lambda$.
    Thus, we can initialize:
    \[\Delta= \lceil F/\Lambda \rceil \]
    The criterion for assigning zero length to an edge is as follows:
    \begin{definition}[Length function]
        Let $r$ be the residual function of any residual graph $G_f$. We define the length function $l((u,v))$ as a function that associate to the edge $(u,v)$ the value 1 or 0 as follow:
            \[l(u.w) = \left \{ \begin{array}{ll}
            0 & r_{vw} \ge 3\Delta\\
            1 & altrimenti
        \end{array} \right .\]
    \end{definition}
    
    However, to achieve the desired computational cost, it is necessary to add a specification to this function.
    \begin{definition}[Special Arc]

        Any edge $(v,w)$ is said \textbf{special} If it meets all the following requirements:
        \begin{itemize}
            \item $2\Delta \le r_{v,w} < 3\Delta$
            \item $d(v) = d(w)$
            \item $r_{wv} \ge 3\Delta$
        \end{itemize}
    \end{definition}  
    

    By applying this definition to the length function, we can define a more complex function, which we distinguish from the first by calling it $\bar{l} $.
    The modified function also takes into account special edges:
    \[\bar{l}(u.w) = \left \{ \begin{array}{ll}
        0 & r_{vw} \ge 3\Delta \lor specialArc((v,w))\\
        1 & altrimenti
    \end{array} \right .\]
    \begin{obs}
        Introducing special edges does not change the distance labeling: $d_l = d_{\bar{l}}$
    \end{obs}


    \begin{lemma}[From contract to original]
        \label{fixCont}
        Let's suppose we have contracted the original network as described so far, and routed a flow $f$ through the contracted graph.

        The computational cost of adapting this flow through the original graph is $O(m)$.
    \end{lemma}
    \begin{proof}

        Through the following steps, it is intuitive how the flow can be adapted:

        \begin{enumerate}[nolistsep] 
            \item Choose any vertex in each contracted component. 
            \item Form an in-tree and an out-tree rooted at the chosen vertices. 
            \item Route the positive flow from the in-tree to the root. 
            \item From the out-tree, redirect the incoming flow from the root to all other connected nodes. 
        \end{enumerate}

    Since the maximum flow we route is \dlt\ and all nodes in the contracted components have a cost of at least $2\Delta$, we are assured that the flow respects the capacities of the network.
    It is evident that this method has a cost directly proportional to the number of edges in the connected components.
    \end{proof}

    \subsection{How to increase distance}
    In Dinic's Algorithm, the proof that the blocking flow strictly increases the distance between $s$ and $t$ is quite obvious.
    The same cannot be said for the Goldberg-Rao case due to the presence of zero-length edges. Therefore, it is essential to prove the following theorem to ensure that the algorithm terminates.
    \begin{theorem}{Blocking flow with binary length}{}
        Let $\bar{f}$ be a flow in $A(f,\bar{l}, d_l)$, let $f' = f + \bar{f}$ be the increased flow, and let 
        $l'$ be the length function corresponding to $f'$.
        Then:
        \begin{enumerate}
            \item $d_l$ is a distance labeling with respect to $l'$
            \item $d_{l'}(s) \ge d_l(s)$
            \item if $\bar{f}$ is blocking $\implies$ $d_{l'}(s) > d_l(s)$
        \end{enumerate}
    \end{theorem}
    \begin{proof}
        Let's proceed point by point
    
            \paragraph*{\underline{1. $d_l$ is a distance lebeling with respect to $l'$}}
            By the definition of distance labeling, $d_l(v) \le d_l(w) + \bar{l}(v,w)$ (remembering that $d_l = d_{\bar{l}}$),
            we therefore need to prove that  $d_l(v) \le d_l(w) + l'(v,w)$.\\
            This is trivially true if $d_l(v) \le d_l(w)$.\\
            If $d_l(v) > d_l(w)$ i.e. $d_{\bar{l}}(v) > d_{\bar{l}}(w)$ then $(w,v)$ is not admissible with respect to $\bar{l}$.\\
            Since $l'(v,w)\ge \bar{l}(v,w)$, the statement follows.

            \paragraph*{\underline{2. $d_{l'}(s) \ge d_l(s)$}}

            Let \( L := \{ l_0, l_1, ..., l_n \} \) be the ordered set of all length functions calculated between the iterations of the algorithm. Then, for any \( 0 \le i \le j \le n \), we have \( d_{l_i}(s) \le d_{l_j}(s) \).

            We distinguish between two iterations as follows:
            \begin{enumerate}
                \item In iteration \( i \):
                Let \( l(u,v) = l_i(u,v) \) be the length function and \( d(x) = d_{l_i}(x) \) be the distance. Together with the flow, they define \( A(f, l_i, d_{l_i}) \). Let \( \Gamma \) be the shortest \( s \rightarrow t \) path in \( A \), where \( \Gamma \subseteq A \).
                \item In iteration \( j \):
                Let \( l'(u,v) = l_j(u,v) \) be the length function and \( d'(x) = d_{l_j}(x) \) be the distance. Together with the flow, they define \( A'(f, l_j, d_{l_j}) \). Let \( \Gamma' \) be the shortest \( s \rightarrow t \) path in \( A' \), where \( \Gamma' \subseteq A' \).
            \end{enumerate}
       
            Suppose by contradiction that there exist two iterations \( 0 \le i \le j \) such that \( d(s) > d'(s) \):
            \[
            \implies \exists \Gamma \, s \rightarrow t,\ \Gamma' \, s \rightarrow t : \sum_{(v,w) \in \Gamma} l(v,w) \ge \sum_{(v,w) \in \Gamma'} l'(v,w)
            \]
            In other words, as the iterations progress, \( s \) and \( t \) have gotten closer.

            We immediately exclude the case where \( \Gamma = \Gamma' \) since
            \[
            \forall (v,w) \in A \cap A',\ l(v,w) \le l'(v,w) \implies l(\Gamma) \le l'(\Gamma')
            \]
            \textbf{Note:} \( l(\Gamma) = \sum_{(v,w) \in \Gamma} l(v,w) \).

            Now consider \( \Gamma \) and \( \Gamma' \). Let \( w \) be the last node in \( \Gamma \) for which \( d(w) > d'(w) \), and let \( x \) be the next node:
            \[
            w \in \Gamma : d(w) > d'(w) \land \exists x = succ_{\Gamma}(w) : d(x) \le d'(x)
            \]
            \( w \) and \( x \) are always well defined because we assume \( d(s) > d'(s) \) and \( d(t) = d'(t) = 0 \) by definition.

            Thus, there exists an arc \( (w,y) \) in \( \Gamma' \) with \( y \neq x \) such that \( d'(y) < d'(x) \). \( x \neq y \), because if they were the same node, then:
            \[
            d'(w) = d'(x) + l'(w,x) \ge d(w)
            \]
            which contradicts the hypothesis.

            To summarize, we know that:
            \begin{enumerate}
                \item \( d(w) > d'(w) \iff d(x) + l(w,x) > d'(y) + l'(w,y) \).While we don't know the exact distance \( d(y) \), we know that:
            \[
            d'(y) = \sum_{(a,b) \in y-t \subseteq \Gamma'} l'(a,b) \ge \sum_{(a,b) \in y-t \subseteq \Gamma'} l(a,b)
            \]
            Therefore, the path in iteration \( j \) is greater than or equal to the path in iteration \( i \).
                \item \( d(y) + l(w,y) \le d'(y) + l'(w,y) < d(x) + l(w,x) \).
            \end{enumerate}

            However, we know that \( d(w) = d(x) + l(w,x) \), which is \textbf{absurd} because it is not the minimal distance from \( w \rightarrow t \), as it is greater than \( d(y) + l(w,y) \).

            We know for certain that the path \( w-y \rightarrow t \) exists in \( A \) because (unless there is a shorter one) it represents the minimal distance from \( w \rightarrow t \).

            From this contradiction, the only conclusions are that either the path through \( y \) was not reachable in iteration \( i \), making it impossible to reach it later, or if a shorter \( s \rightarrow t \) path exists in iteration \( j \) than in iteration \( i \), we made an error in considering the path in iteration \( i \).

        
            \paragraph*{\underline{3. Se $\bar{f}$ è bloccante allora $d_l(s) < d_{l'}(s)$}}

            To show that the blocking flow increases the distance of node \( s \), we define the following notation:
            \[
            c(v,w) := d_l(w) - d_l(v) + l'(v,w)
            \]
            which represents the change in length of an edge connecting two adjacent nodes.

            We can assert that:
            \[
            \forall (v,w) \in E, \, c(v,w) \ge 0
            \]
            since \( l'(v,w) \ge l(v,w) \), which implies:
            \[
            d_l(w) - d_l(v) < 0 \iff l(v,w) = 1 \implies l'(v,w) = 1
            \]

            Now, consider any path \( \Gamma \) in \( G_{f'} \), the length of the path is equal to:
            \[
            l'(\Gamma) = d_l(s) + c(\Gamma)
            \]
            Therefore, to show that the path is longer, we need to show that:
            \[
            \forall \text{ shortest } s-t \text{ path } \Gamma \in G_{f'} \implies \exists (v,w) \in \Gamma \, \text{where} \, c(v,w) > 0
            \]

            We now have a tool to demonstrate that the blocking flow increases the distance of \( s \).

            \begin{table}[H]
                \centering
                \caption{graphic example to better visualize what was declared}
            \begin{tabular}{c|c}

                \\
                \begin{tikzpicture}[node distance={14mm}, thick , main/.style = {draw, circle}] 
                \node[main] (1) at (0,0) {$s$}; 
                \node[main] (2) [above right of=1] {$2$};
                \node[main] (3) [right of=2] {$3$};
                \node[main] (4) [right of=3] {$4$};
                \node[main] (5) [below right of=1] {$5$};
                \node[main] (6) [right of=5] {$6$};
                \node[main] (7) [right of=6] {$7$};
                \node[main] (9) [below right of=4] {$t$};
                \node[main] (8) at ($(1)!0.5!(9)$) {$8$};
                %Admissible
                \draw[->] (1) to (2);
                \draw[-] (2) to [red, midway] node {X} (3);
                \draw[-] (3) to (4);
                \draw[-] (4) to (9);
                \draw[-] (3) to (8);
                \draw[-] (2) to (8);
                \draw[-] (8) to (7);
                \draw[->] (1) to (5);
                \draw[-] (5) to (6);
                \draw[-] (6) to (7);
                \draw[-] (7) to [red, midway] node {X} (9);
                
                %paths
                \draw[->,line width=1 pt] (1)[babyblue, bend left] to (2);
                \draw[->,line width=1 pt] (2)[babyblue, bend left] to (3);
                \draw[->,line width=1 pt] (3)[babyblue, bend left] to (4);
                \draw[->,line width=1 pt] (4)[babyblue, bend left] to (9);
            
                \draw[->,line width=1 pt] (1)[blue, bend right] to (5);
                \draw[->,line width=1 pt] (5)[blue, bend right] to (6);
                \draw[->,line width=1 pt] (6)[blue, bend right] to (7);
                \draw[->,line width=1 pt] (7)[blue, bend right] to (9);

            
            \end{tikzpicture} 
            &
            \begin{tikzpicture}[node distance={14mm}, thick , main/.style = {draw, circle}] 
                \node[main] (1) at (0,0) {$s$}; 
                \node[main] (2) [above right of=1] {$2$};
                \node[main] (3) [right of=2] {$3$};
                \node[main] (4) [right of=3] {$4$};
                \node[main] (5) [below right of=1] {$5$};
                \node[main] (6) [right of=5] {$6$};
                \node[main] (7) [right of=6] {$7$};
                \node[main] (9) [below right of=4] {$t$};
                \node[main] (8) at ($(1)!0.5!(9)$) {$8$};
                %Admissible
                \draw[->] (1) to (2);
                \draw[-] (3) to (4);
                \draw[-] (4) to (9);
                \draw[-] (3) to (8);
                \draw[-] (2) to (8);
                \draw[-] (8) to (7);
                \draw[->] (1) to (5);
                \draw[-] (5) to (6);
                \draw[-] (6) to (7);
                
                \draw[->,line width=1 pt] (1)[brightgreen, bend left] to (2);
                \draw[->,line width=1 pt] (2)[brightgreen, bend left] to (8);
                \draw[->,line width=1 pt] (8)[brightgreen, bend right] to (3);
                \draw[->,line width=1 pt] (3)[brightgreen, bend left] to (4);
                \draw[->,line width=1 pt] (4)[brightgreen, bend left] to (9);

            \end{tikzpicture}\\

            \textbf{\color{blue}{blu}} $\bar{f}$ in $A(f,\bar{l}, d_l)$ &
            \end{tabular}
            \end{table}

            Since \( \bar{f} \) is blocking in \( A(f,\bar{l}, d_l) \), \( \Gamma \) must contain an edge \( (v,w) \) that is not present in \( A(f,\bar{l}, d_l) \).
            
            Furthermore, we can state that \( d_l(v) \leq d_l(w) \), either because \( (v,w) \in G_f \), but then if \( d_l(v) > d_l(w) \), we would have \( (v,w) \in A(f,\bar{l}, d_l) \),  
            or because \( (v,w) \notin G_f \), but it appears in \( G_{f'} \), which is only possible if the flow is incremented in the opposite direction, causing the residual edge to appear. Therefore, \( (w,v) \in A(f,\bar{l}, d_l) \), which implies that \( d_l(v) \leq d_l(w) \).
            
            Now, suppose for contradiction that \( c(v,w) = 0 \), so \( d_l(v) = d_l(w) \) and \( l'(v,w) = 0 \).  
            The fact that \( (v,w) \) is not in \( A(f,\bar{l}, d_l) \) implies that either \( (v,w) \) is not in \( G_f \), but then we have already shown that the opposite edge \( (w,v) \in A(f,\bar{l}, d_l) \),  
            or that \( (v,w) \in G_f \) but does not meet the distance labeling requirements to belong to the \nameref{AdmissibleGraph} \( A(f,\bar{l}, d_l) \).  
            Since \( d_l(v) = d_l(w) \), then \( l(v,w) = 1 \). We note that \( 1 = l(v,w) > l'(v,w) = 0 \), which implies that we have incremented the flow on the opposite edge \( (w,v) \).  
            Thus, in any case, the edge \( (w,v) \in A(f,\bar{l}, d_l) \).
            
            As shown earlier, since \( d_l(v) = d_l(w) \),  
            \[
            (w,v) \in A(f,\bar{l}, d_l) \iff l(w,v) = 0
            \]  
            We conclude that:
            \begin{itemize}
                \item During the flow increments, we routed a flow (of at most \( \Delta \)) through the edge \( (w,v) \)
                \item \( u_f(w,v) \geq 3\Delta \) because \( l(w,v) = 0 \)
                \item After this increment, we have \( u_{f'}(v,w) \geq 3\Delta \) because \( l'(v,w) = 0 \)
                \item Thus \( u_f(v,w) \geq 2\Delta \)
                \item But then the edge \( (v,w) \) was a \textit{special edge} even before the increment, since \( d_l(v) = d_l(w) \land u_f(w,v) \geq 3\Delta \land u_f(v,w) \geq 2\Delta \)
            \end{itemize}
            We therefore conclude that:
            \[
            d_l(v) = d_l(w) \implies d_{\bar{l}}(v) = d_{\bar{l}}(w) \land \bar{l}(v,w) = 0 \implies (v,w) \in A(f,\bar{l}, d_l)
            \]
            which is a contradiction.
            
\end{proof}

\section{Costo computazionale}
    Abbiamo già mostrato che per trovare il max flow nel grafo 
    Prima di addentrarci nel costo di una fase, rivediamo la struttura dell'algoritmo descritto fino ad ora.

    \begin{algorithm}
        \caption{\textit{Goldberg-RaoAlgorithm(G, c)}}
        \label{algotrans}
        \begin{algorithmic}[1]
            \State $n = |N(G)|$
            \State $F = U\cdot n$
            \State $\Delta = F/ \Lambda$
            \For{$(i,j)\in E(G)$}
                $f_{ij} = 0$
            \EndFor
            \While{$F \ge 1$}
                \State $l = update\_length(n, \Delta)$ \Comment return a length function w.r.t. \dlt
                \State $d_l = BFS(G_f, l)$ \Comment return a distance labeling w.r.t. $l$
                \State $G^c = contract(G_f, l)$ 
                \State $A = A(G^c, d_l, l)$ \Comment return the admissible graph
                \State $f' = find\_blocking\_or\_Delta\_flow(A)$ \Comment Dinic's style 
                \State $f_{ad} = fit(f')$ \Comment the procedure to adapt the flow to the original graph
                \State $f = f + f_{ad}$
                \State $c = r(canCutCapacity(G_f,d, l))$
                \If $c \le F/2:$ 
                    \State $F = c$
                    \State $\Delta = F/\Lambda$
                \EndIf
            \EndWhile 
            \State \Return $f$
        \end{algorithmic}
    \end{algorithm}

    \begin{verbatim}
    def Goldberg_Rao_Algorithm(Network network)
        F = U*n
        Delta = F/Lambda
        f = 0
        while F >= 1:
            l = update_length(n, Delta)
            d_l = distanceLabel(network, l)
            Gc = collapse(network)
            Ag = admissible_graph(g)
            f' = find_blocking_or_Delta_flow(Ag)
            f = f + f'
            network.fitFlow(f)
            if min_canonical_cut(network).residual() <= F/2: 
                F = min_canonical_cut(network).residual()
                Delta = F/Lambda

        return f
        
    \end{verbatim}
\textbf{Remark:}
        
        Il costo dichiarato in partenza è in:
        \[O(\min \{n^{2/3}, m^{1/2}\}\cdot m \log n\log m U_{max})\]
        utilizzando strutture dati più avanzate, si può raggiungere il costo di:
        \[O(\min \{n^{2/3}, m^{1/2}\}\cdot m \log \frac{n^2}{m}\log U_{max})\]


    Abbiamo già notato che il numero di \textbf{fasi} (ovvero il numero di decrementi) di F è nell'ordine di $\log(F)$ ovvero $log(m U_{max})$.
    Il costo per calcolare il min canonical cut e per adattare il flow al network sono entrambi in $O(m)$.
    Resta però da analizzare il costo di ogni fase, cioè quanto in fretta il min canonical cut si dimezza.
    \begin{lemma}
        {}{}
        La capacità minima di un canonical cut $(\bar{S}, \bar{T})$ soddisfa
        \[u_f(\bar{S}, \bar{T})\le \frac{mM}{d_l(s)}\]
        dove M rappresenta l'arco di lunghezza uno con più capacità
    \end{lemma}
    \begin{proof}
        Risulta evidente che il il modo migliore in cui si può massimizzare la capacita del taglio canonico minimo è supponendo che tutti gli archi abbiano la capacità dell'arco di capacità maggiore e poi dividere equamente gli archi tra i vari tagli.

    \end{proof}

    Da questa prima stima segue il corollario
    \begin{corollary}{}{}
    Durante ogni fase ci sono al massimo $O(\Lambda)$ blocking flow incrementi.
    \end{corollary}
    \begin{proof}
        Supponiamo che $\Lambda = m^{1/2}$ dato che abbiamo dimostrato che ogni blocking flow incrementa $d(s)$ di almeno uno, siamo sicuri che dopo $6\lceil \Lambda\rceil$ incrementi $d_l(s) \ge 6 m^{1/2}$.
        Dunque possiamo prendere la stima nel lemma e affermare che:
        \[ u_f(\bar{S}, \bar{T})\le \frac{mM}{d_l(s)}\le \frac{3m}{d_l(s)}\Delta\le \frac{3m}{6m^{1/2}}\frac{F}{m^{1/2}} = \frac{F}{2}\]
        Dunque dopo $\lceil \Lambda\rceil$ la fase termina.\\
        Per $\Lambda = n^{2/3}$ la dimostrazione è analoga e porta alla stessa conclusione. 
        In conclusione, il costo di ogni fase è in ordine di $O(\Lambda)$ 
    \end{proof}
    
    L'ultimo collo di bottiglia è rappresentato dal costo di trovare un blocking flow o di valore massimo $\Delta$ (computazionalmente equivalenti):
    il che richiederebbe un costo di:
    \begin{itemize}
        \item $O(mn)$ in un approccio naive;
        \item $O(m\log n)$ utilizzando i dynamic trees;
        \item $O(m \log(n^2/m))$ utilizzando i size-bounded dynamic trees;
    \end{itemize}
    Unendo il costo di:
    \begin{itemize}[label=$\times$]
        \item trovare un Blocking flow
        \item le iterazioni in ogni fase
        \item il numero di fasi
        \item gli ulteriori costi in $O(m)$
    \end{itemize}
    Si ottiene il tempo dichiarato.


\cleardoublepage